<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> You don't Know JS - this & prototype 笔记 · Shane Hsi Rocks</title><meta name="description" content="1. 关于 thisthis 关键字是 JavaScript 最复杂的机制之一。
被自动定义在所有函数的作用域中。
很难说清它指向什么。
实际上 this 没有那么先进。但是开发者往往把理解过程复杂化。
1.1 为什么要用 this不同的上下文对象。重复使用的函数。
12&lt;/sp"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="https://github.com/shane13hsi" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">You don't Know JS - this & prototype 笔记</h1><div class="post-meta"><div class="post-time">Feb 5, 2016</div></div><div class="post-content"><h1 id="1-__u5173_u4E8E_this"><a href="#1-__u5173_u4E8E_this" class="headerlink" title="1. 关于 this"></a>1. 关于 <code>this</code></h1><p><code>this</code> 关键字是 JavaScript 最复杂的机制之一。</p>
<p>被自动定义在所有函数的作用域中。</p>
<p>很难说清它指向什么。</p>
<p>实际上 <code>this</code> 没有那么先进。但是开发者往往把理解过程复杂化。</p>
<h2 id="1-1__u4E3A_u4EC0_u4E48_u8981_u7528_this"><a href="#1-1__u4E3A_u4EC0_u4E48_u8981_u7528_this" class="headerlink" title="1.1 为什么要用 this"></a>1.1 为什么要用 <code>this</code></h2><p>不同的上下文对象。重复使用的函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identify</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name.toUpperCase();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> me = &#123;</span><br><span class="line">    name: <span class="string">"Kyle"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> you = &#123;</span><br><span class="line">    name: <span class="string">"Reader"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">identify.call(me); <span class="comment">// KYLE</span></span><br><span class="line">identify.call(you); <span class="comment">// READER</span></span><br></pre></td></tr></table></figure>
<p>如果不是 <code>this</code>，就是显式传入。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identify</span><span class="params">(context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> context.name.toUpperCase();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，<code>this</code> 提供了一种更优雅的方式来隐式『传递』一个对象引用。可以将API设计的更加简洁。</p>
<p>随着模式越来越复杂，显式传递上下文对象会让代码越来越混乱。</p>
<p>当介绍到对象和原型时，你会明白函数自动引用合适的上下文对象是多么的重要。</p>
<h2 id="1-2__u8BEF_u89E3"><a href="#1-2__u8BEF_u89E3" class="headerlink" title="1.2 误解"></a>1.2 误解</h2><p>之后解释 <code>this</code> 的具体用法，先消除误解。</p>
<p>不要拘泥于 <code>this</code> 的字面解释。以下是错误的。</p>
<h3 id="1-2-1__u6307_u5411_u81EA_u8EAB"><a href="#1-2-1__u6307_u5411_u81EA_u8EAB" class="headerlink" title="1.2.1 指向自身"></a>1.2.1 指向自身</h3><p><code>this</code> 不指向函数自身。</p>
<p>如果 <code>this</code> 要指向自身，什么场景？递归，调用函数内储存的状态（属性的值）。本书介绍的其他模式，有比函数对象更适合储存状态的地方。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo: "</span> + num);</span><br><span class="line">    <span class="keyword">this</span>.count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; <span class="number">5</span>) &#123;</span><br><span class="line">        foo(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo: 6</span></span><br><span class="line"><span class="comment">// foo: 7</span></span><br><span class="line"><span class="comment">// foo: 8</span></span><br><span class="line"><span class="comment">// foo: 9</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo.count); <span class="comment">// 0 -- WFT?</span></span><br></pre></td></tr></table></figure>
<p><code>this.count</code> 无意间创建了一个全局变量。最终的值是 <code>NaN</code>。</p>
<p>当然，也可以使用词法作用域（舒适区）规避这个问题。不过不能放弃对 <code>this</code> 的学习。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo: "</span> + num);</span><br><span class="line">    data.count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果要从函数内部引用自身，只用 <code>this</code> 是不够的。</p>
<p>一般来说要通过一个 <strong>指向函数对象的词法标识符（变量）</strong> 来引用它。</p>
<p>思考下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    foo.count = <span class="number">4</span>; <span class="comment">// foo 指向自身</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 匿名函数无法指向自身</span></span><br><span class="line">&#125;, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>第一个函数称为具名函数，在内部可以通过 <code>foo</code> 引用自身。</p>
<p>所以，还有一种解决方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo: "</span> + num);</span><br><span class="line">    foo.count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.count = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>然而，这种方法还是回避了 <code>this</code>，完全依赖于变量 <code>foo</code> 的词法作用域。</p>
<p>另一种方法是强制 <code>this</code> 指向 <code>foo</code>（使用 <code>call</code>）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; <span class="number">5</span>) &#123;</span><br><span class="line">        foo.call(foo, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这次我们接受了 <code>this</code>。后面会解释。</p>
<h3 id="1-2-2__u5B83_u7684_u4F5C_u7528_u57DF"><a href="#1-2-2__u5B83_u7684_u4F5C_u7528_u57DF" class="headerlink" title="1.2.2 它的作用域"></a>1.2.2 它的作用域</h3><p>第二种常见的误解是，<code>this</code> 指向函数的作用域。这个问题有点复杂，某些情况下正确，其他是错误的。</p>
<p>但是，需要明确，<code>this</code> 在任何情况下都不指向函数的作用域。</p>
<p>在 JavaScript 中，作用域确实和对象类似，可见标识符都是它的属性。但是作用域对象无法通过 JavaScript 代码访问。它存在于 JavaScript 引擎内部。</p>
<p>思考下这段代码，它试图（没有成功）跨越边界，使用 <code>this</code> 隐式引用函数的词法作用域：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">this</span>.bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();  <span class="comment">// ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure>
<p>这段代码的错误不止一个，非常完美（同时令人伤感地）展示了 <code>this</code> 多么容易误导人。</p>
<ul>
<li><p><code>this.bar()</code> 引用 <code>bar()</code> 是绝对不可能成功的。之后会解释原因。最自然的方法是略去 <code>this</code>，直接使用词法 <strong>引用标识符</strong>。</p>
</li>
<li><p>还试图使用 <code>this</code> 联通 <code>foo()</code> 和 <code>bar()</code> 的词法作用域。从而让 <code>bar()</code> 可以访问 <code>foo()</code> 作用域里的变量 <code>a</code>。这是不可能的。不能使用 <code>this</code> 来引用一个词法作用域内部的东西。</p>
</li>
</ul>
<p>每当你想把 <code>this</code> 和 <strong>词法作用域查找</strong> 混合使用的时候，一定要提醒自己，这是不可能实现的。</p>
<h2 id="1-3_this__u5230_u5E95_u662F_u4EC0_u4E48"><a href="#1-3_this__u5230_u5E95_u662F_u4EC0_u4E48" class="headerlink" title="1.3 this 到底是什么"></a>1.3 <code>this</code> 到底是什么</h2><p><code>this</code> 是在运行时绑定的，不是函数声明的位置。取决于函数调用时的各种条件。</p>
<p>当一个函数被调用时，会创建一个活动记录（有时候也成为执行上下文）。</p>
<p>这个记录会包含函数</p>
<ul>
<li>在哪里被调用（调用栈）</li>
<li>函数的调用方法</li>
<li>传入的参数</li>
<li>等</li>
</ul>
<p><code>this</code> 就是记录了其中一个属性，它会在执行过程中用到。</p>
<h2 id="1-4__u5C0F_u7ED3"><a href="#1-4__u5C0F_u7ED3" class="headerlink" title="1.4 小结"></a>1.4 小结</h2><p>要投入时间去理解。</p>
<p>第一步是消除两个误解，<code>this</code> 既不指向函数自身，也不指向函数的词法作用域。</p>
<p><code>this</code> 在函数被调用中发生时的绑定，取决于调用方式。</p>
<h1 id="2-_this__u5168_u9762_u89E3_u6790"><a href="#2-_this__u5168_u9762_u89E3_u6790" class="headerlink" title="2. this 全面解析"></a>2. <code>this</code> 全面解析</h1><h2 id="2-1__u8C03_u7528_u4F4D_u7F6E"><a href="#2-1__u8C03_u7528_u4F4D_u7F6E" class="headerlink" title="2.1 调用位置"></a>2.1 调用位置</h2><p>怎么找调用位置？似乎就是函数被调用的位置。但是不是那么简单，某些编程模式会隐藏真正的调用位置。</p>
<p>最重要的是分析 <strong>调用栈</strong> （即为了到达当前执行位置调用的所有函数，可以想象成一个函数调用链）。我们关心的调用位置就是当前执行函数的前一个调用。</p>
<p>使用浏览器的调试工具可以方便得查看调用栈。</p>
<h2 id="2-2__u7ED1_u5B9A_u89C4_u5219"><a href="#2-2__u7ED1_u5B9A_u89C4_u5219" class="headerlink" title="2.2 绑定规则"></a>2.2 绑定规则</h2><p>函数在执行过程中如何决定 <code>this</code> 的绑定对象。</p>
<p>找到调用位置，判断应用下面4条规则的哪一条。</p>
<h3 id="2-2-1__u9ED8_u8BA4_u7ED1_u5B9A"><a href="#2-2-1__u9ED8_u8BA4_u7ED1_u5B9A" class="headerlink" title="2.2.1 默认绑定"></a>2.2.1 默认绑定</h3><p>独立函数调用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">foo(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p><code>a</code> 首先是全局对象。</p>
<p>但是，<code>this</code> 指向的也是全局对象。</p>
<p>但是，如果是 “strict mode”，全局对象无法使用默认绑定，则是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="pi">    "use strict"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">foo(); <span class="comment">// TypeError: this is undefined</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>理解这层意思，但是规避这种写法。</p>
</blockquote>
<h3 id="2-2-2__u9690_u5F0F_u7ED1_u5B9A"><a href="#2-2-2__u9690_u5F0F_u7ED1_u5B9A" class="headerlink" title="2.2.2 隐式绑定"></a>2.2.2 隐式绑定</h3><p>调用位置是否有上下文对象，或者说是否被某个对象包含或拥有。严格说来，后面一句的说法不准确：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line">obj.foo(); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>严格说来，<code>foo()</code> 不属于 <code>obj</code> 对象。</p>
<p>然而，调用位置，会使用 <code>obj</code> 上下文来引用函数。</p>
<p>对象属性引用链只有最顶层或者说最后一层会影响调用位置。举例来说：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    a: <span class="number">42</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    obj2: obj2</span><br><span class="line">&#125;;</span><br><span class="line">obj1.obj2.foo(); <span class="comment">//42</span></span><br></pre></td></tr></table></figure>
<p><strong>隐式丢失</strong>：</p>
<p>被隐式绑定的函数会丢失绑定对象，也就是说会应用默认绑定（取决于是否是 “strict mode”，决定 <code>this</code> 是绑定到全局对象还是 undefined）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = obj.foo; <span class="comment">// 函数别名</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"opps, global"</span>; <span class="comment">// a 是全局对象的属性</span></span><br><span class="line">bar(); <span class="comment">//"oops, global"</span></span><br></pre></td></tr></table></figure>
<p>虽然，<code>bar</code> 和 <code>obj.foo</code> 是一个引用，但是实际上，它引用的确实 <code>foo</code> 函数本身。还是要看函数有没有修饰。</p>
<p>还有一种同样道理，但是较隐蔽，常在回调函数中出现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dooFoo</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// fn 其实引用的是 foo</span></span><br><span class="line">    fn(); <span class="comment">// &lt;-- 调用位置！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"opps, global"</span>; <span class="comment">// a 是全局对象的属性</span></span><br><span class="line">doFoo( obj.foo ); <span class="comment">//"oops, global"</span></span><br></pre></td></tr></table></figure>
<p>参数传递其实就是一种隐式传递（隐式赋值）。</p>
<p>内置函数也是一样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(obj.foo ,<span class="number">100</span>); <span class="comment">//"opps, global"</span></span><br></pre></td></tr></table></figure>
<p>因为在 browser 端，<code>setTimeout</code> 大概伪代码是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setTimeout</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 等待delay毫秒</span></span><br><span class="line">    fn(); <span class="comment">// &lt;-- 调用位置！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，回调函数丢失 <code>this</code> 绑定是很常见的。</p>
<p>含有更出乎意料的，某些流行的 JavaScrit 库中事件处理器常会把回调函数的 <code>this</code> 强制绑定到触发时间的 DOM 元素中（郁闷）。</p>
<p>反正， <code>this</code> 的改变都是意想不到的。</p>
<p>之后我们会介绍如何通过固定 <code>this</code> 来修复。</p>
<h3 id="2-2-3__u663E_u5F0F_u7ED1_u5B9A"><a href="#2-2-3__u663E_u5F0F_u7ED1_u5B9A" class="headerlink" title="2.2.3 显式绑定"></a>2.2.3 显式绑定</h3><p>再回顾下 <strong>隐式绑定</strong>。</p>
<p>是将函数作为一个对象的属性引用，通过属性间接调用函数，从而把 <code>this</code> 间接（隐式）绑定到这个对象上。</p>
<p>现在显式，就是指，强制在某个对象上调用函数。</p>
<p>利用 JavaScript 的原型，使用 <code>call(..)</code> 和 <code>apply(..)</code> 方法。</p>
<p>它们的第一个参数，就是调用时，<code>this</code> 会指定绑定的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line">foo.call(obj); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>如果是 primitive 类型的值，会被转换成它的对象形式（<code>new String(..)</code>、<code>new Boolean(..)</code>、<code>new Number(..)</code>。这通常被称为『装箱』。</p>
<p>可惜，显式绑定也并不能解决丢失绑定的问题。原因是会修改。现在要做的是，找到一种方式，不会修改 this。</p>
<p><strong>1. 硬绑定</strong></p>
<p>显式绑定的一种变种可以解决这个问题（通过创建一个包裹函数，这样起作用的 <code>call</code> 就不会被修改了）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 包裹函数</span></span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    foo.call(obj);</span><br><span class="line">&#125;</span><br><span class="line">bar(); <span class="comment">// 2</span></span><br><span class="line">setTimeout( bar, <span class="number">100</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 硬绑定的bar不可能再修改它的 this</span></span><br><span class="line">bar.call(<span class="built_in">window</span>); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>参数形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> foo.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提取下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">fn, obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fn.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于硬绑定是一种常用的模式，在 ES5 里提供了内置的方式：<code>Function.prototype.bind</code>。</p>
<blockquote>
<p>所以，bind 返回的是一个硬编码的新函数</p>
</blockquote>
<p><strong>2. API 调用的『上下文』</strong></p>
<p>第三方库的许多函数，JavaScript 语言和宿主环境中的很多新的函数，都提供了一个可选参数，通常被称为『上下文』（context），作用和 <code>bind</code> 一样，确保回调使用的是指定的 <code>this</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach( foo, obj); <span class="comment">// obj 就是第二个可选参数</span></span><br></pre></td></tr></table></figure>
<p>内部实际上就是用 <code>bind</code> 或者 <code>apply</code> 实现了显式绑定，减少了些代码。</p>
<h3 id="2-2-4_new__u7ED1_u5B9A"><a href="#2-2-4_new__u7ED1_u5B9A" class="headerlink" title="2.2.4 new 绑定"></a>2.2.4 <code>new</code> 绑定</h3><p>最后一条，但在此之前，先澄清一个常见误解，关于 JavaScript 中函数和对象的误解。</p>
<p>在传统的面向类的语言中，『构造函数』是类中的一些特殊方法。使用 <code>new</code> 初始化类时会调用类中的构造函数，常如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sth = <span class="keyword">new</span> MyClz();</span><br></pre></td></tr></table></figure>
<p>JavaScript 也有 <code>new</code>，使用方式类似，然而机制真得完全不同。</p>
<p>首先，重定义下 JavaScript 中的『构造函数』:</p>
<p>JavaScript 中，构造函数只是使用 <code>new</code> 操作符时被调用的函数。它们并不属于某个类，也不会实例化一个类。实际上，你都不能把构造函数认为是一种特殊的函数类型（即可以不要这个名称），它们只是被 <code>new</code> 操作符调用的普通函数而已。</p>
<p>例，<code>Number(..)</code> 作为构造函数（指会通过 <code>new</code> 操作符调用时）时的行为。</p>
<blockquote>
<p>当 Number 在 new 表达式中被调用时，它是一个构造函数：它会初始化新创建的对象。</p>
</blockquote>
<p>所以，包括内置对象函数（比如 <code>Number</code>，详情见Ch3）在内的所有函数都可以用 <code>new</code> 来调用。这种函数通常被称为『构造函数调用』。</p>
<p>这里有一个重要但非常细微的区别：</p>
<p><strong>实际上并不存在所谓的『构造函数』，只有对于函数的『构造调用』</strong>。</p>
<p>使用 <code>new</code> 来调用函数，或者说发生构造函数调用时，会自动执行以下操作：</p>
<ol>
<li>创建（或者说构造）一个全新的对象</li>
<li>这个新对象会被执行[[原型]]链接，即将构造函数的 prototype 复制到新对象的 <code>__proto__</code>。</li>
<li>这个新对象会绑定到函数调用的 <code>this</code></li>
<li>如果函数没有返回其他对象，那么 <code>new</code> 表达式中的函数调用会自动返回这个新对象</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> foo(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bar.a); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>总结下，这称为 <code>new</code> 绑定。</p>
<h2 id="2-3__u4F18_u5148_u7EA7"><a href="#2-3__u4F18_u5148_u7EA7" class="headerlink" title="2.3 优先级"></a>2.3 优先级</h2><p>本节介绍了 ES5 和 MDN <code>bind</code> 的实现（polyfill），new 的优先级是会改变硬绑定的 this。这么设计的原因是为了做『部分应用』，是『柯里化』的一种。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">p1, p2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.val = p1 + p2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = foo.bind(<span class="literal">null</span>, <span class="string">"p1"</span>);</span><br><span class="line"><span class="keyword">var</span> baz = <span class="keyword">new</span> bar(<span class="string">"p2"</span>);</span><br><span class="line">baz.val; <span class="comment">//p1p2</span></span><br></pre></td></tr></table></figure>
<h2 id="2-4__u89C4_u5219_u7684_u4F8B_u5916"><a href="#2-4__u89C4_u5219_u7684_u4F8B_u5916" class="headerlink" title="2.4 规则的例外"></a>2.4 规则的例外</h2><h3 id="2-4-1__u88AB_u5FFD_u7565_u7684_this"><a href="#2-4-1__u88AB_u5FFD_u7565_u7684_this" class="headerlink" title="2.4.1 被忽略的 this"></a>2.4.1 被忽略的 this</h3><p>如果传入 null 或者 undefined，会使用默认绑定。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">foo.call(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>所以使用的 null 要注意下影响面。</p>
<p>更安全的 <code>this</code>，是做一个特殊对象。其实是为了规避这条例外的规则，传入一个不是 null，但是也没啥意义的特殊对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ø = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<h3 id="2-4-2__u95F4_u63A5_u5F15_u7528"><a href="#2-4-2__u95F4_u63A5_u5F15_u7528" class="headerlink" title="2.4.2 间接引用"></a>2.4.2 间接引用</h3><blockquote>
<p>这个我觉得不是其规则例外，而是一种伪装的规则。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>; <span class="comment">// global</span></span><br><span class="line"><span class="keyword">var</span> o = &#123; a: <span class="number">3</span>, foo: foo&#125;;</span><br><span class="line"><span class="keyword">var</span> p = &#123; a : <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line">o.foo(); <span class="comment">//3</span></span><br><span class="line">(p.foo = o.foo)(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>(p.foo = o.foo)()</code> 看，调用操作符的位置。</p>
<p>但是如果是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.foo = o.foo;</span><br><span class="line">p.foo(); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<h2 id="2-5_this_u8BCD_u6CD5"><a href="#2-5_this_u8BCD_u6CD5" class="headerlink" title="2.5 this词法"></a>2.5 this词法</h2><p>ES6 介绍的胖箭头函数，<code>=&gt;</code>。不适用 this 的四条标准规则，而是根据外层（函数或者全局）作用域来决定 this。当然，外层的 this 是适用于上述四条标准规则的。（像是静态动态的结合）。</p>
<p>箭头函数的 this 无法被修改，通过 new 也不行。</p>
<p>其实就是我们经常在 ES5 用到的方式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>; <span class="comment">// lexical capture of this</span></span><br><span class="line">    setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( self.a );</span><br><span class="line">    &#125;, <span class="number">100</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果经常编写 this 风格的代码，但绝大多数情况都使用 self = this 或者箭头函数来否定 this 机制，那你或许应当：</p>
<ul>
<li>只使用词法作用域并完全抛弃错误 this 风格的代码。</li>
<li>完全使用 this 风格，在必要时使用 bind，尽量避免使用 self=this 或者箭头函数。</li>
</ul>
<h1 id="3__u5BF9_u8C61"><a href="#3__u5BF9_u8C61" class="headerlink" title="3 对象"></a>3 对象</h1><h2 id="3-1__u8BED_u6CD5"><a href="#3-1__u8BED_u6CD5" class="headerlink" title="3.1 语法"></a>3.1 语法</h2><p>对象可以通过两种形式定义：声明（文字）形式和构造形式。</p>
<p>文字语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">    key: value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造形式（非常少见）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">myObj.key = value;</span><br></pre></td></tr></table></figure>
<h2 id="3-2__u7C7B_u578B"><a href="#3-2__u7C7B_u578B" class="headerlink" title="3.2 类型"></a>3.2 类型</h2><p>一共六种主要类型（术语是语言类型）：</p>
<ul>
<li>string</li>
<li>number</li>
<li>boolean</li>
<li>null</li>
<li>undefined</li>
<li>object</li>
</ul>
<p>前5个是简单基本类型（primitive），本身不是对象。</p>
<blockquote>
<p>typeof null 返回的是 “object”，这是语言本身的一个 bug，null 本身是基本类型。出现这个 bug 的原因是，不同的对象在底层都表示为二进制。在 JavaScript 中，二进制前三位都是0，被判断为 object 类型。null 的二进制表示全是0。</p>
</blockquote>
<p>有一种常见的错误说法是，JavaScript 中万物皆对象。</p>
<p><strong>内置对象</strong>：某些名字和 primitive 类型一样，具体稍后介绍：</p>
<ul>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
<li>Object</li>
<li>Function</li>
<li>Array</li>
<li>Date</li>
<li>RegExp</li>
<li>Error</li>
</ul>
<h2 id="3-3__u5185_u5BB9"><a href="#3-3__u5185_u5BB9" class="headerlink" title="3.3 内容"></a>3.3 内容</h2><h3 id="3-3-4__u590D_u5236_u5BF9_u8C61"><a href="#3-3-4__u590D_u5236_u5BF9_u8C61" class="headerlink" title="3.3.4 复制对象"></a>3.3.4 复制对象</h3><p>JavaScript 初学者最常见的问题之一就是如何复制一个对象。实际上比较复杂。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) <span class="title">anotherFunction</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="keyword">var</span> anotherObject = &#123;</span><br><span class="line">    c: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anotherArray = [];</span><br><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    b: anotherObject, <span class="comment">// 引用，不是复制</span></span><br><span class="line">    c: anotherArray, <span class="comment">// 另一个引用</span></span><br><span class="line">    d: anotherFunction</span><br><span class="line">&#125;;</span><br><span class="line">anotherArray.push(anotherObject, myObject);</span><br></pre></td></tr></table></figure>
<p>那么，如何准确地表示 myObject 的复制呢？</p>
<p>首先，要判断是浅复制还是深复制。</p>
<p>浅复制中，新对象中的 <code>a:2</code> 是一份新的拷贝，但是，<code>b</code>，<code>c,</code>，<code>d</code> 只是引用，新对象也是引用。</p>
<p>如果是深复制，会有循环引用导致死循环。</p>
<p>对于 JSON 安全 的对象，有一种巧妙的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(someObj));</span><br></pre></td></tr></table></figure>
<p>相比于深复制，浅复制相对易懂问题少，Object.assign()，第一个参数就是目标对象，后面是源对象。它会遍历所有源对象的可枚举（enumerable）的自有键（owned key，后面介绍）并把它们复制（使用 <code>=</code> 操作符）到目标对象，最后返回目标对象。</p>
<blockquote>
<p>下一节介绍『属性描述符』以及 <code>Object.defineProperty()</code> 的用法。要注意，由于 <code>Object.assign</code> 就是使用 <code>=</code> 操作符来赋值，所以源对象属性的一些特性（比如 <code>writable</code>）不会被复制到目标对象。</p>
</blockquote>
<h3 id="3-3-5__u5C5E_u6027_u63CF_u8FF0_u7B26"><a href="#3-3-5__u5C5E_u6027_u63CF_u8FF0_u7B26" class="headerlink" title="3.3.5 属性描述符"></a>3.3.5 属性描述符</h3><p>在 ES5 之前，JavaScript 没有提供检测属性特性的方法，比如判断属性是否是只读。</p>
<p>从 ES5 开始，所有的属性具备属性描述符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(myObject, <span class="string">"a"</span>);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// value: 2,</span></span><br><span class="line"><span class="comment">//    writable: true,</span></span><br><span class="line"><span class="comment">//    enumerable: true,</span></span><br><span class="line"><span class="comment">//    configurable: true</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p>所以，可不仅仅是一个 2。可写，可枚举，可配置。</p>
<p>我们可以使用 <code>Object.defineProperty()</code> 来添加一个新属性，或者修改一个已有属性（如果它是 <code>configurable</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(myObject, <span class="string">"a"</span>, &#123;</span><br><span class="line">    value: <span class="number">2</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line">myObject.a; <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p><strong>1. Writable</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;;</span><br><span class="line"> <span class="built_in">Object</span>.defineProperty( myObject, <span class="string">"a"</span>, &#123;</span><br><span class="line">     value: <span class="number">2</span>,</span><br><span class="line">     writable: <span class="literal">false</span>, <span class="comment">// not writable!</span></span><br><span class="line">     configurable: <span class="literal">true</span>,</span><br><span class="line">     enumerable: <span class="literal">true</span></span><br><span class="line"> &#125; );</span><br><span class="line"> myObject.a = <span class="number">3</span>;</span><br><span class="line"> myObject.a; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>如你所见，修改失败。如果是 “use strict”; 则会报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myObject.a = <span class="number">3</span>; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>
<p><strong>2. Configurable</strong></p>
<p>表示是否可以使用 <code>defineProperty</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myObject.a = <span class="number">3</span>;</span><br><span class="line">myObject.a; <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(myObject, <span class="string">"a"</span>, &#123;</span><br><span class="line">    value: <span class="number">4</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">false</span>, <span class="comment">//       enumerable: true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myObject.a; <span class="comment">// 4</span></span><br><span class="line">myObject.a = <span class="number">5</span>;</span><br><span class="line">myObject.a; <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(myObject, <span class="string">"a"</span>, &#123;</span><br><span class="line">    value: <span class="number">6</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span></span><br><span class="line">&#125;); <span class="comment">// TypeError，不管是不是严格模式</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有一个小小的意外，即便属性是 configurable: <span class="literal">false</span>，依然可以 writable 由 <span class="literal">true</span> 改为 <span class="literal">false</span>。不能由 <span class="literal">false</span> 改为 <span class="literal">true</span>。</span><br></pre></td></tr></table></figure>
<p>除了无法修改，<code>configurable: false</code> 还会禁止删除这个属性（<code>delete</code> 不会报错，静默失败）。</p>
<p><strong>3. Enumerable</strong></p>
<p>这个属性描述符（Property Descriptor）控制的是属性是否会出现在对象的属性枚举中。比如 <code>for .. in</code>。</p>
<h3 id="3-3-6__u4E0D_u53D8_u6027"><a href="#3-3-6__u4E0D_u53D8_u6027" class="headerlink" title="3.3.6 不变性"></a>3.3.6 不变性</h3><ol>
<li>对象常量</li>
</ol>
<p>结合 <code>writable: false</code> 和 <code>configurable: false</code>。</p>
<ol>
<li>禁止扩展</li>
</ol>
<p><code>Object.preventExtensions()</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">     a:<span class="number">2</span></span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="built_in">Object</span>.preventExtensions( myObject );</span><br><span class="line"> myObject.b = <span class="number">3</span>;</span><br><span class="line"> myObject.b; <span class="comment">// undefined，严格模式是 TypeError</span></span><br></pre></td></tr></table></figure>
<ol>
<li>密封</li>
</ol>
<p><code>Object.seal(..)</code>。实际上在一个现有对象上调用 <code>Object.preventExtensions()</code>，并将现有（由于了禁止扩展，也无法添加新的属性）属性的 <code>configurable: false</code>。密封之后，禁止扩展，也不能重新配置或者删除。但是可以修改属性的值。</p>
<ol>
<li>冻结</li>
</ol>
<p><code>Object.freeze(..)</code>。这个方法会在现有对象上调用 <code>Object.seal()</code>，并把所有对象的 <code>writable: false</code>。这样就无法修改他们的值。</p>
<p>这个方法是应用在对象上的级别最高的不可变性。（但是，这个对象引用的其他对象是不受影响的）。</p>
<h3 id="3-3-7__5B_5BGet_5D_5D"><a href="#3-3-7__5B_5BGet_5D_5D" class="headerlink" title="3.3.7 [[Get]]"></a>3.3.7 [[Get]]</h3><p>属性访问在实现时有一个微妙却非常重要的细节：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line">myObject.a; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p><code>myObject.a</code> 在 <code>myObject</code> 实际上是实现的 <code>[[Get]]</code> 操作（有点像函数调用，<code>[[Get]]()</code>）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">     a: <span class="literal">undefined</span></span><br><span class="line"> &#125;;</span><br><span class="line"> myObject.a; <span class="comment">// undefined</span></span><br><span class="line"> myObject.b; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>从返回值看好像没有区别，但是底层 <code>[[Get]]</code> 做了更复杂的处理。</p>
<p>稍后会介绍如何区分。</p>
<h3 id="3-3-8__5B_5BPut_5D_5D"><a href="#3-3-8__5B_5BPut_5D_5D" class="headerlink" title="3.3.8 [[Put]]"></a>3.3.8 [[Put]]</h3><h3 id="3-3-9_Getter__u548C_Setter"><a href="#3-3-9_Getter__u548C_Setter" class="headerlink" title="3.3.9 Getter 和 Setter"></a>3.3.9 Getter 和 Setter</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">    get a() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(myObject,</span><br><span class="line">    <span class="string">"b"</span>: &#123;</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.a * <span class="number">2</span></span><br><span class="line">        &#125;,</span><br><span class="line">        enumerable: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">myObject.a; <span class="comment">// 2</span></span><br><span class="line">myObject.b; <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">    get a() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myObject.a = <span class="number">3</span>;</span><br><span class="line">myObject.a; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">    get a() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._a_;</span><br><span class="line">    &#125;,</span><br><span class="line">    set a(val) &#123;</span><br><span class="line">        <span class="keyword">this</span>._a_ = val * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">myObject.a = <span class="number">2</span>;</span><br><span class="line">myObject.a; <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-10__u5B58_u5728_u6027"><a href="#3-3-10__u5B58_u5728_u6027" class="headerlink" title="3.3.10 存在性"></a>3.3.10 存在性</h3><p>暂时不看。</p>
<h1 id="4-__u6DF7_u5408_u5BF9_u8C61__u300E_u7C7B_u300F"><a href="#4-__u6DF7_u5408_u5BF9_u8C61__u300E_u7C7B_u300F" class="headerlink" title="4. 混合对象 『类』"></a>4. 混合对象 『类』</h1><p>实例化（instantiation），继承（inheritance）和（相对）多态（polymorphism）。</p>
<h2 id="4-1__u7C7B_u7406_u8BBA"><a href="#4-1__u7C7B_u7406_u8BBA" class="headerlink" title="4.1 类理论"></a>4.1 类理论</h2><p>面向对象认为，数据和操作数据的行为本质上是互联的。好的设计是将数据和它相关的行为打包（封住）。这个在 CS 中叫做数据结构。</p>
<p>继承类是对基类定义的特殊化。</p>
<p>类，继承和实例化。所谓实例化，类只是抽象的表示，必须实例化后才能进行操作。</p>
<p>类的另一个核心概念是多态，父类的通用行为可以被子类用更特殊的行为重写。</p>
<p>类理论强烈建议父类和子类使用相同的方法名表示特定的行为。</p>
<p>我们之后会看到，在 JavaScript 代码中会降低代码的可读性和健壮性。</p>
<h3 id="4-1-3_JavaScript__u4E2D_u7684_u300E_u7C7B_u300F"><a href="#4-1-3_JavaScript__u4E2D_u7684_u300E_u7C7B_u300F" class="headerlink" title="4.1.3 JavaScript 中的『类』"></a>4.1.3 JavaScript 中的『类』</h3><p>其他语言中的类和JavaScript 中的『类』不一样。</p>
<h2 id="4-2__u7C7B_u7684_u673A_u5236"><a href="#4-2__u7C7B_u7684_u673A_u5236" class="headerlink" title="4.2 类的机制"></a>4.2 类的机制</h2><p>由于很多开发者喜欢面向类的设计模式，下面会介绍如何在 JavaScript 中实现类以及存在的一些问题。</p>
<h2 id="4-4__u6DF7_u5165"><a href="#4-4__u6DF7_u5165" class="headerlink" title="4.4 混入"></a>4.4 混入</h2><p>在继承或者实例化时，JavaScript 的对象机制并不会自动执行复制行为。简单来说，JavaScript 只有对象，并不存在可以实例化的『类』。</p>
<p>一个对象不会被复制到其他对象，只是被关联起来。</p>
<p>JavaScript 程序员也想出了一种方法来模拟类的复制行为 - 混入。</p>
<p>包括：显式和隐式。</p>
<h1 id="5__u539F_u578B"><a href="#5__u539F_u578B" class="headerlink" title="5 原型"></a>5 原型</h1><p><code>[[Prototype]]</code> 链。（也就是 <code>__proto__</code>）。</p>
<h2 id="5-1__5B_5BPrototype_5D_5D"><a href="#5-1__5B_5BPrototype_5D_5D" class="headerlink" title="5.1 [[Prototype]]"></a>5.1 <code>[[Prototype]]</code></h2><p>是 JavaScript 对象的一个特殊的内置属性，其实就是对其他对象的引用。几乎所有的对象在创建时 <code>[[Prototype]]</code>  都会被赋予一个非空的值。</p>
<p>注意：对象的 <code>[[Prototype]]</code> 可以为空，虽然很少见。</p>
<p>稍后会介绍 <code>Object.create(..)</code> 的原理。现在只需要知道，它会创建一个对象并把这个对象的 <code>[[prototype]]</code> 关联到指定的对象。</p>
<h3 id="Object-prototype"><a href="#Object-prototype" class="headerlink" title="Object.prototype"></a><code>Object.prototype</code></h3><p>哪里是 <code>[[Prototype]]</code> 的尽头？</p>
<p>所有普通的 <code>[[Prototype]]</code> 链最终都指向内置的 <code>Object.prototype</code>。</p>
<h3 id="5-1-2__u5C5E_u6027_u8BBE_u7F6E_u548C_u5C4F_u853D"><a href="#5-1-2__u5C5E_u6027_u8BBE_u7F6E_u548C_u5C4F_u853D" class="headerlink" title="5.1.2 属性设置和屏蔽"></a>5.1.2 属性设置和屏蔽</h3><p><code>myObject.foo = &quot;bar&quot;</code></p>
<p>主要涉及到 <code>[[Prototype]]</code> 链上层是否有 <code>foo</code>，是否是只读 <code>writable:false</code>，或者是不是存在 <code>setter</code>。</p>
<p>总之，这里面有很多规则没有做到封闭。有例外。</p>
<h1 id="5-2__u300E_u7C7B_u300F"><a href="#5-2__u300E_u7C7B_u300F" class="headerlink" title="5.2 『类』"></a>5.2 『类』</h1><p>JavaScript 和面向类的语言不同，它没有类来作为对象的抽象模式或者蓝图。</p>
<p>JavaScript 只有对象。可以不通过类，直接创建对象。</p>
<h3 id="5-2-1__u300E_u7C7B_u300F_u51FD_u6570"><a href="#5-2-1__u300E_u7C7B_u300F_u51FD_u6570" class="headerlink" title="5.2.1 『类』函数"></a>5.2.1 『类』函数</h3><p>模仿类。</p>
<p>利用函数的一种特性，所有函数都会默认拥有一个名为 <code>prototype</code> 的公有并且不可枚举的属性。它会指向另一个对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prototype;</span><br></pre></td></tr></table></figure>
</div></article></div></section><footer><div class="paginator"><a href="/2016/02/05/Read-some-Zhihu-2016-02-05/" class="prev">上一篇</a><a href="/2016/02/04/React-performance-zh-cn/" class="next">下一篇</a></div></footer><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>