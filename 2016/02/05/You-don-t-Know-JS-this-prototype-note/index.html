<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> You don't Know JS - this & prototype note · Shane Hsi Rocks</title><meta name="description" content="1. 关于 thisthis 关键字是 JavaScript 最复杂的机制之一。
被自动定义在所有函数的作用域中。
很难说清它指向什么。
实际上 this 没有那么先进。但是开发者往往把理解过程复杂化。
1.1 为什么要用 this不同的上下文对象。重复使用的函数。
12&lt;/sp"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="https://github.com/shane13hsi" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">You don't Know JS - this & prototype note</h1><div class="post-meta"><div class="post-time">Feb 5, 2016</div></div><div class="post-content"><h1 id="1-__u5173_u4E8E_this"><a href="#1-__u5173_u4E8E_this" class="headerlink" title="1. 关于 this"></a>1. 关于 <code>this</code></h1><p><code>this</code> 关键字是 JavaScript 最复杂的机制之一。</p>
<p>被自动定义在所有函数的作用域中。</p>
<p>很难说清它指向什么。</p>
<p>实际上 <code>this</code> 没有那么先进。但是开发者往往把理解过程复杂化。</p>
<h2 id="1-1__u4E3A_u4EC0_u4E48_u8981_u7528_this"><a href="#1-1__u4E3A_u4EC0_u4E48_u8981_u7528_this" class="headerlink" title="1.1 为什么要用 this"></a>1.1 为什么要用 <code>this</code></h2><p>不同的上下文对象。重复使用的函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identify</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name.toUpperCase();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> me = &#123;</span><br><span class="line">    name: <span class="string">"Kyle"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> you = &#123;</span><br><span class="line">    name: <span class="string">"Reader"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">identify.call(me); <span class="comment">// KYLE</span></span><br><span class="line">identify.call(you); <span class="comment">// READER</span></span><br></pre></td></tr></table></figure>
<p>如果不是 <code>this</code>，就是显式传入。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identify</span><span class="params">(context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> context.name.toUpperCase();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，<code>this</code> 提供了一种更优雅的方式来隐式『传递』一个对象引用。可以将API设计的更加简洁。</p>
<p>随着模式越来越复杂，显式传递上下文对象会让代码越来越混乱。</p>
<p>当介绍到对象和原型时，你会明白函数自动引用合适的上下文对象是多么的重要。</p>
<h2 id="1-2__u8BEF_u89E3"><a href="#1-2__u8BEF_u89E3" class="headerlink" title="1.2 误解"></a>1.2 误解</h2><p>之后解释 <code>this</code> 的具体用法，先消除误解。</p>
<p>不要拘泥于 <code>this</code> 的字面解释。以下是错误的。</p>
<h3 id="1-2-1__u6307_u5411_u81EA_u8EAB"><a href="#1-2-1__u6307_u5411_u81EA_u8EAB" class="headerlink" title="1.2.1 指向自身"></a>1.2.1 指向自身</h3><p><code>this</code> 不指向函数自身。</p>
<p>如果 <code>this</code> 要指向自身，什么场景？递归，调用函数内储存的状态（属性的值）。本书介绍的其他模式，有比函数对象更适合储存状态的地方。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo: "</span> + num);</span><br><span class="line">    <span class="keyword">this</span>.count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; <span class="number">5</span>) &#123;</span><br><span class="line">        foo(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo: 6</span></span><br><span class="line"><span class="comment">// foo: 7</span></span><br><span class="line"><span class="comment">// foo: 8</span></span><br><span class="line"><span class="comment">// foo: 9</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo.count); <span class="comment">// 0 -- WFT?</span></span><br></pre></td></tr></table></figure>
<p><code>this.count</code> 无意间创建了一个全局变量。最终的值是 <code>NaN</code>。</p>
<p>当然，也可以使用词法作用域（舒适区）规避这个问题。不过不能放弃对 <code>this</code> 的学习。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo: "</span> + num);</span><br><span class="line">    data.count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果要从函数内部引用自身，只用 <code>this</code> 是不够的。</p>
<p>一般来说要通过一个 <strong>指向函数对象的词法标识符（变量）</strong> 来引用它。</p>
<p>思考下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    foo.count = <span class="number">4</span>; <span class="comment">// foo 指向自身</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 匿名函数无法指向自身</span></span><br><span class="line">&#125;, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>第一个函数称为具名函数，在内部可以通过 <code>foo</code> 引用自身。</p>
<p>所以，还有一种解决方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo: "</span> + num);</span><br><span class="line">    foo.count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.count = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>然而，这种方法还是回避了 <code>this</code>，完全依赖于变量 <code>foo</code> 的词法作用域。</p>
<p>另一种方法是强制 <code>this</code> 指向 <code>foo</code>（使用 <code>call</code>）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; <span class="number">5</span>) &#123;</span><br><span class="line">        foo.call(foo, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这次我们接受了 <code>this</code>。后面会解释。</p>
<h3 id="1-2-2__u5B83_u7684_u4F5C_u7528_u57DF"><a href="#1-2-2__u5B83_u7684_u4F5C_u7528_u57DF" class="headerlink" title="1.2.2 它的作用域"></a>1.2.2 它的作用域</h3><p>第二种常见的误解是，<code>this</code> 指向函数的作用域。这个问题有点复杂，某些情况下正确，其他是错误的。</p>
<p>但是，需要明确，<code>this</code> 在任何情况下都不指向函数的作用域。</p>
<p>在 JavaScript 中，作用域确实和对象类似，可见标识符都是它的属性。但是作用域对象无法通过 JavaScript 代码访问。它存在于 JavaScript 引擎内部。</p>
<p>思考下这段代码，它试图（没有成功）跨越边界，使用 <code>this</code> 隐式引用函数的词法作用域：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">this</span>.bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();  <span class="comment">// ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure>
<p>这段代码的错误不止一个，非常完美（同时令人伤感地）展示了 <code>this</code> 多么容易误导人。</p>
<ul>
<li><p><code>this.bar()</code> 引用 <code>bar()</code> 是绝对不可能成功的。之后会解释原因。最自然的方法是略去 <code>this</code>，直接使用词法 <strong>引用标识符</strong>。</p>
</li>
<li><p>还试图使用 <code>this</code> 联通 <code>foo()</code> 和 <code>bar()</code> 的词法作用域。从而让 <code>bar()</code> 可以访问 <code>foo()</code> 作用域里的变量 <code>a</code>。这是不可能的。不能使用 <code>this</code> 来引用一个词法作用域内部的东西。</p>
</li>
</ul>
<p>每当你想把 <code>this</code> 和 <strong>词法作用域查找</strong> 混合使用的时候，一定要提醒自己，这是不可能实现的。</p>
<h2 id="1-3_this__u5230_u5E95_u662F_u4EC0_u4E48"><a href="#1-3_this__u5230_u5E95_u662F_u4EC0_u4E48" class="headerlink" title="1.3 this 到底是什么"></a>1.3 <code>this</code> 到底是什么</h2><p><code>this</code> 是在运行时绑定的，不是函数声明的位置。取决于函数调用时的各种条件。</p>
<p>当一个函数被调用时，会创建一个活动记录（有时候也成为执行上下文）。</p>
<p>这个记录会包含函数</p>
<ul>
<li>在哪里被调用（调用栈）</li>
<li>函数的调用方法</li>
<li>传入的参数</li>
<li>等</li>
</ul>
<p><code>this</code> 就是记录了其中一个属性，它会在执行过程中用到。</p>
<h2 id="1-4__u5C0F_u7ED3"><a href="#1-4__u5C0F_u7ED3" class="headerlink" title="1.4 小结"></a>1.4 小结</h2><p>要投入时间去理解。</p>
<p>第一步是消除两个误解，<code>this</code> 既不指向函数自身，也不指向函数的词法作用域。</p>
<p><code>this</code> 在函数被调用中发生时的绑定，取决于调用方式。</p>
<h1 id="2-_this__u5168_u9762_u89E3_u6790"><a href="#2-_this__u5168_u9762_u89E3_u6790" class="headerlink" title="2. this 全面解析"></a>2. <code>this</code> 全面解析</h1><h2 id="2-1__u8C03_u7528_u4F4D_u7F6E"><a href="#2-1__u8C03_u7528_u4F4D_u7F6E" class="headerlink" title="2.1 调用位置"></a>2.1 调用位置</h2><p>怎么找调用位置？似乎就是函数被调用的位置。但是不是那么简单，某些编程模式会隐藏真正的调用位置。</p>
<p>最重要的是分析 <strong>调用栈</strong> （即为了到达当前执行位置调用的所有函数）。我们关心的调用位置就是当前执行函数的前一个调用。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/02/05/Read-some-Zhihu-2016-02-05/" class="prev">上一篇</a><a href="/2016/02/04/React-performance-zh-cn/" class="next">下一篇</a></div></footer><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>