<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> You don't Know JS - this & prototype 笔记 · Shane Hsi Rocks</title><meta name="description" content="1. 关于 thisthis 关键字是 JavaScript 最复杂的机制之一。
被自动定义在所有函数的作用域中。
很难说清它指向什么。
实际上 this 没有那么先进。但是开发者往往把理解过程复杂化。
1.1 为什么要用 this不同的上下文对象。重复使用的函数。
12&lt;/sp"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="https://github.com/shane13hsi" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">You don't Know JS - this & prototype 笔记</h1><div class="post-meta"><div class="post-time">Feb 5, 2016</div></div><div class="post-content"><h1 id="1-__u5173_u4E8E_this"><a href="#1-__u5173_u4E8E_this" class="headerlink" title="1. 关于 this"></a>1. 关于 <code>this</code></h1><p><code>this</code> 关键字是 JavaScript 最复杂的机制之一。</p>
<p>被自动定义在所有函数的作用域中。</p>
<p>很难说清它指向什么。</p>
<p>实际上 <code>this</code> 没有那么先进。但是开发者往往把理解过程复杂化。</p>
<h2 id="1-1__u4E3A_u4EC0_u4E48_u8981_u7528_this"><a href="#1-1__u4E3A_u4EC0_u4E48_u8981_u7528_this" class="headerlink" title="1.1 为什么要用 this"></a>1.1 为什么要用 <code>this</code></h2><p>不同的上下文对象。重复使用的函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identify</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name.toUpperCase();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> me = &#123;</span><br><span class="line">    name: <span class="string">"Kyle"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> you = &#123;</span><br><span class="line">    name: <span class="string">"Reader"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">identify.call(me); <span class="comment">// KYLE</span></span><br><span class="line">identify.call(you); <span class="comment">// READER</span></span><br></pre></td></tr></table></figure>
<p>如果不是 <code>this</code>，就是显式传入。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identify</span><span class="params">(context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> context.name.toUpperCase();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，<code>this</code> 提供了一种更优雅的方式来隐式『传递』一个对象引用。可以将API设计的更加简洁。</p>
<p>随着模式越来越复杂，显式传递上下文对象会让代码越来越混乱。</p>
<p>当介绍到对象和原型时，你会明白函数自动引用合适的上下文对象是多么的重要。</p>
<h2 id="1-2__u8BEF_u89E3"><a href="#1-2__u8BEF_u89E3" class="headerlink" title="1.2 误解"></a>1.2 误解</h2><p>之后解释 <code>this</code> 的具体用法，先消除误解。</p>
<p>不要拘泥于 <code>this</code> 的字面解释。以下是错误的。</p>
<h3 id="1-2-1__u6307_u5411_u81EA_u8EAB"><a href="#1-2-1__u6307_u5411_u81EA_u8EAB" class="headerlink" title="1.2.1 指向自身"></a>1.2.1 指向自身</h3><p><code>this</code> 不指向函数自身。</p>
<p>如果 <code>this</code> 要指向自身，什么场景？递归，调用函数内储存的状态（属性的值）。本书介绍的其他模式，有比函数对象更适合储存状态的地方。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo: "</span> + num);</span><br><span class="line">    <span class="keyword">this</span>.count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; <span class="number">5</span>) &#123;</span><br><span class="line">        foo(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo: 6</span></span><br><span class="line"><span class="comment">// foo: 7</span></span><br><span class="line"><span class="comment">// foo: 8</span></span><br><span class="line"><span class="comment">// foo: 9</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo.count); <span class="comment">// 0 -- WFT?</span></span><br></pre></td></tr></table></figure>
<p><code>this.count</code> 无意间创建了一个全局变量。最终的值是 <code>NaN</code>。</p>
<p>当然，也可以使用词法作用域（舒适区）规避这个问题。不过不能放弃对 <code>this</code> 的学习。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo: "</span> + num);</span><br><span class="line">    data.count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果要从函数内部引用自身，只用 <code>this</code> 是不够的。</p>
<p>一般来说要通过一个 <strong>指向函数对象的词法标识符（变量）</strong> 来引用它。</p>
<p>思考下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    foo.count = <span class="number">4</span>; <span class="comment">// foo 指向自身</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 匿名函数无法指向自身</span></span><br><span class="line">&#125;, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>第一个函数称为具名函数，在内部可以通过 <code>foo</code> 引用自身。</p>
<p>所以，还有一种解决方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo: "</span> + num);</span><br><span class="line">    foo.count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.count = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>然而，这种方法还是回避了 <code>this</code>，完全依赖于变量 <code>foo</code> 的词法作用域。</p>
<p>另一种方法是强制 <code>this</code> 指向 <code>foo</code>（使用 <code>call</code>）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; <span class="number">5</span>) &#123;</span><br><span class="line">        foo.call(foo, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这次我们接受了 <code>this</code>。后面会解释。</p>
<h3 id="1-2-2__u5B83_u7684_u4F5C_u7528_u57DF"><a href="#1-2-2__u5B83_u7684_u4F5C_u7528_u57DF" class="headerlink" title="1.2.2 它的作用域"></a>1.2.2 它的作用域</h3><p>第二种常见的误解是，<code>this</code> 指向函数的作用域。这个问题有点复杂，某些情况下正确，其他是错误的。</p>
<p>但是，需要明确，<code>this</code> 在任何情况下都不指向函数的作用域。</p>
<p>在 JavaScript 中，作用域确实和对象类似，可见标识符都是它的属性。但是作用域对象无法通过 JavaScript 代码访问。它存在于 JavaScript 引擎内部。</p>
<p>思考下这段代码，它试图（没有成功）跨越边界，使用 <code>this</code> 隐式引用函数的词法作用域：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">this</span>.bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();  <span class="comment">// ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure>
<p>这段代码的错误不止一个，非常完美（同时令人伤感地）展示了 <code>this</code> 多么容易误导人。</p>
<ul>
<li><p><code>this.bar()</code> 引用 <code>bar()</code> 是绝对不可能成功的。之后会解释原因。最自然的方法是略去 <code>this</code>，直接使用词法 <strong>引用标识符</strong>。</p>
</li>
<li><p>还试图使用 <code>this</code> 联通 <code>foo()</code> 和 <code>bar()</code> 的词法作用域。从而让 <code>bar()</code> 可以访问 <code>foo()</code> 作用域里的变量 <code>a</code>。这是不可能的。不能使用 <code>this</code> 来引用一个词法作用域内部的东西。</p>
</li>
</ul>
<p>每当你想把 <code>this</code> 和 <strong>词法作用域查找</strong> 混合使用的时候，一定要提醒自己，这是不可能实现的。</p>
<h2 id="1-3_this__u5230_u5E95_u662F_u4EC0_u4E48"><a href="#1-3_this__u5230_u5E95_u662F_u4EC0_u4E48" class="headerlink" title="1.3 this 到底是什么"></a>1.3 <code>this</code> 到底是什么</h2><p><code>this</code> 是在运行时绑定的，不是函数声明的位置。取决于函数调用时的各种条件。</p>
<p>当一个函数被调用时，会创建一个活动记录（有时候也成为执行上下文）。</p>
<p>这个记录会包含函数</p>
<ul>
<li>在哪里被调用（调用栈）</li>
<li>函数的调用方法</li>
<li>传入的参数</li>
<li>等</li>
</ul>
<p><code>this</code> 就是记录了其中一个属性，它会在执行过程中用到。</p>
<h2 id="1-4__u5C0F_u7ED3"><a href="#1-4__u5C0F_u7ED3" class="headerlink" title="1.4 小结"></a>1.4 小结</h2><p>要投入时间去理解。</p>
<p>第一步是消除两个误解，<code>this</code> 既不指向函数自身，也不指向函数的词法作用域。</p>
<p><code>this</code> 在函数被调用中发生时的绑定，取决于调用方式。</p>
<h1 id="2-_this__u5168_u9762_u89E3_u6790"><a href="#2-_this__u5168_u9762_u89E3_u6790" class="headerlink" title="2. this 全面解析"></a>2. <code>this</code> 全面解析</h1><h2 id="2-1__u8C03_u7528_u4F4D_u7F6E"><a href="#2-1__u8C03_u7528_u4F4D_u7F6E" class="headerlink" title="2.1 调用位置"></a>2.1 调用位置</h2><p>怎么找调用位置？似乎就是函数被调用的位置。但是不是那么简单，某些编程模式会隐藏真正的调用位置。</p>
<p>最重要的是分析 <strong>调用栈</strong> （即为了到达当前执行位置调用的所有函数，可以想象成一个函数调用链）。我们关心的调用位置就是当前执行函数的前一个调用。</p>
<p>使用浏览器的调试工具可以方便得查看调用栈。</p>
<h2 id="2-2__u7ED1_u5B9A_u89C4_u5219"><a href="#2-2__u7ED1_u5B9A_u89C4_u5219" class="headerlink" title="2.2 绑定规则"></a>2.2 绑定规则</h2><p>函数在执行过程中如何决定 <code>this</code> 的绑定对象。</p>
<p>找到调用位置，判断应用下面4条规则的哪一条。</p>
<h3 id="2-2-1__u9ED8_u8BA4_u7ED1_u5B9A"><a href="#2-2-1__u9ED8_u8BA4_u7ED1_u5B9A" class="headerlink" title="2.2.1 默认绑定"></a>2.2.1 默认绑定</h3><p>独立函数调用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">foo(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p><code>a</code> 首先是全局对象。</p>
<p>但是，<code>this</code> 指向的也是全局对象。</p>
<p>但是，如果是 “strict mode”，全局对象无法使用默认绑定，则是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="pi">    "use strict"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">foo(); <span class="comment">// TypeError: this is undefined</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>理解这层意思，但是规避这种写法。</p>
</blockquote>
<h3 id="2-2-2__u9690_u5F0F_u7ED1_u5B9A"><a href="#2-2-2__u9690_u5F0F_u7ED1_u5B9A" class="headerlink" title="2.2.2 隐式绑定"></a>2.2.2 隐式绑定</h3><p>调用位置是否有上下文对象，或者说是否被某个对象包含或拥有。严格说来，后面一句的说法不准确：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line">obj.foo(); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>严格说来，<code>foo()</code> 不属于 <code>obj</code> 对象。</p>
<p>然而，调用位置，会使用 <code>obj</code> 上下文来引用函数。</p>
<p>对象属性引用链只有最顶层或者说最后一层会影响调用位置。举例来说：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    a: <span class="number">42</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    obj2: obj2</span><br><span class="line">&#125;;</span><br><span class="line">obj1.obj2.foo(); <span class="comment">//42</span></span><br></pre></td></tr></table></figure>
<p><strong>隐式丢失</strong>：</p>
<p>被隐式绑定的函数会丢失绑定对象，也就是说会应用默认绑定（取决于是否是 “strict mode”，决定 <code>this</code> 是绑定到全局对象还是 undefined）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = obj.foo; <span class="comment">// 函数别名</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"opps, global"</span>; <span class="comment">// a 是全局对象的属性</span></span><br><span class="line">bar(); <span class="comment">//"oops, global"</span></span><br></pre></td></tr></table></figure>
<p>虽然，<code>bar</code> 和 <code>obj.foo</code> 是一个引用，但是实际上，它引用的确实 <code>foo</code> 函数本身。还是要看函数有没有修饰。</p>
<p>还有一种同样道理，但是较隐蔽，常在回调函数中出现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dooFoo</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// fn 其实引用的是 foo</span></span><br><span class="line">    fn(); <span class="comment">// &lt;-- 调用位置！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"opps, global"</span>; <span class="comment">// a 是全局对象的属性</span></span><br><span class="line">doFoo( obj.foo ); <span class="comment">//"oops, global"</span></span><br></pre></td></tr></table></figure>
<p>参数传递其实就是一种隐式传递（隐式赋值）。</p>
<p>内置函数也是一样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(obj.foo ,<span class="number">100</span>); <span class="comment">//"opps, global"</span></span><br></pre></td></tr></table></figure>
<p>因为在 browser 端，<code>setTimeout</code> 大概伪代码是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setTimeout</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 等待delay毫秒</span></span><br><span class="line">    fn(); <span class="comment">// &lt;-- 调用位置！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，回调函数丢失 <code>this</code> 绑定是很常见的。</p>
<p>含有更出乎意料的，某些流行的 JavaScrit 库中事件处理器常会把回调函数的 <code>this</code> 强制绑定到触发时间的 DOM 元素中（郁闷）。</p>
<p>反正， <code>this</code> 的改变都是意想不到的。</p>
<p>之后我们会介绍如何通过固定 <code>this</code> 来修复。</p>
<h3 id="2-2-3__u663E_u5F0F_u7ED1_u5B9A"><a href="#2-2-3__u663E_u5F0F_u7ED1_u5B9A" class="headerlink" title="2.2.3 显式绑定"></a>2.2.3 显式绑定</h3><p>再回顾下 <strong>隐式绑定</strong>。</p>
<p>是将函数作为一个对象的属性引用，通过属性间接调用函数，从而把 <code>this</code> 间接（隐式）绑定到这个对象上。</p>
<p>现在显式，就是指，强制在某个对象上调用函数。</p>
<p>利用 JavaScript 的原型，使用 <code>call(..)</code> 和 <code>apply(..)</code> 方法。</p>
<p>它们的第一个参数，就是调用时，<code>this</code> 会指定绑定的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line">foo.call(obj); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>如果是 primitive 类型的值，会被转换成它的对象形式（<code>new String(..)</code>、<code>new Boolean(..)</code>、<code>new Number(..)</code>。这通常被称为『装箱』。</p>
<p>可惜，显式绑定也并不能解决丢失绑定的问题。原因是会修改。现在要做的是，找到一种方式，不会修改 this。</p>
<p><strong>1. 硬绑定</strong></p>
<p>显式绑定的一种变种可以解决这个问题（通过创建一个包裹函数，这样起作用的 <code>call</code> 就不会被修改了）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 包裹函数</span></span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    foo.call(obj);</span><br><span class="line">&#125;</span><br><span class="line">bar(); <span class="comment">// 2</span></span><br><span class="line">setTimeout( bar, <span class="number">100</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 硬绑定的bar不可能再修改它的 this</span></span><br><span class="line">bar.call(<span class="built_in">window</span>); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>参数形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> foo.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提取下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">fn, obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fn.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于硬绑定是一种常用的模式，在 ES5 里提供了内置的方式：<code>Function.prototype.bind</code>。</p>
<blockquote>
<p>所以，bind 返回的是一个硬编码的新函数</p>
</blockquote>
<p><strong>2. API 调用的『上下文』</strong></p>
<p>第三方库的许多函数，JavaScript 语言和宿主环境中的很多新的函数，都提供了一个可选参数，通常被称为『上下文』（context），作用和 <code>bind</code> 一样，确保回调使用的是指定的 <code>this</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach( foo, obj); <span class="comment">// obj 就是第二个可选参数</span></span><br></pre></td></tr></table></figure>
<p>内部实际上就是用 <code>bind</code> 或者 <code>apply</code> 实现了显式绑定，减少了些代码。</p>
<h3 id="2-2-4_new__u7ED1_u5B9A"><a href="#2-2-4_new__u7ED1_u5B9A" class="headerlink" title="2.2.4 new 绑定"></a>2.2.4 <code>new</code> 绑定</h3><p>最后一条，但在此之前，先澄清一个常见误解，关于 JavaScript 中函数和对象的误解。</p>
<p>在传统的面向类的语言中，『构造函数』是类中的一些特殊方法。使用 <code>new</code> 初始化类时会调用类中的构造函数，常如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sth = <span class="keyword">new</span> MyClz();</span><br></pre></td></tr></table></figure>
<p>JavaScript 也有 <code>new</code>，使用方式类似，然而机制真得完全不同。</p>
<p>首先，重定义下 JavaScript 中的『构造函数』:</p>
<p>JavaScript 中，构造函数只是使用 <code>new</code> 操作符时被调用的函数。它们并不属于某个类，也不会实例化一个类。实际上，你都不能把构造函数认为是一种特殊的函数类型（即可以不要这个名称），它们只是被 <code>new</code> 操作符调用的普通函数而已。</p>
<p>例，<code>Number(..)</code> 作为构造函数（指会通过 <code>new</code> 操作符调用时）时的行为。</p>
<blockquote>
<p>当 Number 在 new 表达式中被调用时，它是一个构造函数：它会初始化新创建的对象。</p>
</blockquote>
<p>所以，包括内置对象函数（比如 <code>Number</code>，详情见Ch3）在内的所有函数都可以用 <code>new</code> 来调用。这种函数通常被称为『构造函数调用』。</p>
<p>这里有一个重要但非常细微的区别：</p>
<p><strong>实际上并不存在所谓的『构造函数』，只有对于函数的『构造调用』</strong>。</p>
<p>使用 <code>new</code> 来调用函数，或者说发生构造函数调用时，会自动执行以下操作：</p>
<ol>
<li>创建（或者说构造）一个全新的对象</li>
<li>这个新对象会被执行[[原型]]链接，即将构造函数的 prototype 复制到新对象的 <code>__proto__</code>。</li>
<li>这个新对象会绑定到函数调用的 <code>this</code></li>
<li>如果函数没有返回其他对象，那么 <code>new</code> 表达式中的函数调用会自动返回这个新对象</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> foo(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bar.a); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>总结下，这称为 <code>new</code> 绑定。</p>
<h2 id="2-3__u4F18_u5148_u7EA7"><a href="#2-3__u4F18_u5148_u7EA7" class="headerlink" title="2.3 优先级"></a>2.3 优先级</h2><p>本节介绍了 ES5 和 MDN <code>bind</code> 的实现（polyfill），new 的优先级是会改变硬绑定的 this。这么设计的原因是为了做『部分应用』，是『柯里化』的一种。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">p1, p2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.val = p1 + p2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = foo.bind(<span class="literal">null</span>, <span class="string">"p1"</span>);</span><br><span class="line"><span class="keyword">var</span> baz = <span class="keyword">new</span> bar(<span class="string">"p2"</span>);</span><br><span class="line">baz.val; <span class="comment">//p1p2</span></span><br></pre></td></tr></table></figure>
<h2 id="2-4__u89C4_u5219_u7684_u4F8B_u5916"><a href="#2-4__u89C4_u5219_u7684_u4F8B_u5916" class="headerlink" title="2.4 规则的例外"></a>2.4 规则的例外</h2><h3 id="2-4-1__u88AB_u5FFD_u7565_u7684_this"><a href="#2-4-1__u88AB_u5FFD_u7565_u7684_this" class="headerlink" title="2.4.1 被忽略的 this"></a>2.4.1 被忽略的 this</h3><p>如果传入 null 或者 undefined，会使用默认绑定。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">foo.call(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>所以使用的 null 要注意下影响面。</p>
<p>更安全的 <code>this</code>，是做一个特殊对象。其实是为了规避这条例外的规则，传入一个不是 null，但是也没啥意义的特殊对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ø = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<h3 id="2-4-2__u95F4_u63A5_u5F15_u7528"><a href="#2-4-2__u95F4_u63A5_u5F15_u7528" class="headerlink" title="2.4.2 间接引用"></a>2.4.2 间接引用</h3><blockquote>
<p>这个我觉得不是其规则例外，而是一种伪装的规则。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>; <span class="comment">// global</span></span><br><span class="line"><span class="keyword">var</span> o = &#123; a: <span class="number">3</span>, foo: foo&#125;;</span><br><span class="line"><span class="keyword">var</span> p = &#123; a : <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line">o.foo(); <span class="comment">//3</span></span><br><span class="line">(p.foo = o.foo)(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>(p.foo = o.foo)()</code> 看，调用操作符的位置。</p>
<p>但是如果是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.foo = o.foo;</span><br><span class="line">p.foo(); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<h2 id="2-5_this_u8BCD_u6CD5"><a href="#2-5_this_u8BCD_u6CD5" class="headerlink" title="2.5 this词法"></a>2.5 this词法</h2><p>ES6 介绍的胖箭头函数，<code>=&gt;</code>。不适用 this 的四条标准规则，而是根据外层（函数或者全局）作用域来决定 this。当然，外层的 this 是适用于上述四条标准规则的。（像是静态动态的结合）。</p>
<p>箭头函数的 this 无法被修改，通过 new 也不行。</p>
<p>其实就是我们经常在 ES5 用到的方式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>; <span class="comment">// lexical capture of this</span></span><br><span class="line">    setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( self.a );</span><br><span class="line">    &#125;, <span class="number">100</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果经常编写 this 风格的代码，但绝大多数情况都使用 self = this 或者箭头函数来否定 this 机制，那你或许应当：</p>
<ul>
<li>只使用词法作用域并完全抛弃错误 this 风格的代码。</li>
<li>完全使用 this 风格，在必要时使用 bind，尽量避免使用 self=this 或者箭头函数。</li>
</ul>
</div></article></div></section><footer><div class="paginator"><a href="/2016/02/05/Read-some-Zhihu-2016-02-05/" class="prev">上一篇</a><a href="/2016/02/04/React-performance-zh-cn/" class="next">下一篇</a></div></footer><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>