<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Read TypeScript Blog, Announcing TypeScript 1.7 · Shane Hsi Rocks</title><meta name="description" content="更新：

对于 ES6 targets，默认打开 async/await
polymorphic ‘this’ typing
ES2016 的 exponentiation 语法
ES6 module targeting

Async/Await for ES6 targetsAsyc functions，需要 ES6 generator 支持（比如 node.js v4"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="https://github.com/shane13hsi" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Read TypeScript Blog, Announcing TypeScript 1.7</h1><div class="post-meta"><div class="post-time">Jan 13, 2016</div></div><div class="post-content"><p>更新：</p>
<ul>
<li>对于 ES6 targets，默认打开 async/await</li>
<li>polymorphic ‘this’ typing</li>
<li>ES2016 的 exponentiation 语法</li>
<li>ES6 module targeting</li>
</ul>
<h2 id="Async/Await_for_ES6_targets"><a href="#Async/Await_for_ES6_targets" class="headerlink" title="Async/Await for ES6 targets"></a>Async/Await for ES6 targets</h2><p><a href="http://tc39.github.io/ecmascript-asyncawait/" target="_blank" rel="external">Asyc functions</a>，需要 <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-generator-function-definitions" target="_blank" rel="external">ES6 generator</a> 支持（比如 node.js v4 及以上）。</p>
<p>函数通过 <code>async</code> 关键词指定它为一个 asynchronous function。</p>
<p><code>await</code>关键词用来停止执行（stop execution），直到 <code>async</code> 函数的 promise 已经 fulfilled。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">"use strict"</span>;</span><br><span class="line"><span class="comment">// printDelayed is a 'Promise&lt;void&gt;'</span></span><br><span class="line">async <span class="function"><span class="keyword">function</span> <span class="title">printDelayed</span>(<span class="params">elements: <span class="built_in">string</span>[]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> element of elements) &#123;</span><br><span class="line">        await delay(<span class="number">200</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">async <span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">milliseconds: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise&lt;<span class="built_in">void</span>&gt;(resolve =&gt; &#123;</span><br><span class="line">        setTimeout(resolve, milliseconds);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">printDelayed([<span class="string">"Hello"</span>, <span class="string">"beautiful"</span>, <span class="string">"asynchronous"</span>, <span class="string">"world"</span>]).then(() =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Printed every element!"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>对于目前对 async/await 的实现，参考上一篇<a href="http://blogs.msdn.com/b/typescript/archive/2015/11/03/what-about-async-await.aspx" target="_blank" rel="external">博客</a>。</p>
<h2 id="Polymorphic_this_Typing"><a href="#Polymorphic_this_Typing" class="headerlink" title="Polymorphic this Typing"></a>Polymorphic <code>this</code> Typing</h2><p>背景见 <a href="https://github.com/Microsoft/TypeScript/issues/229" target="_blank" rel="external">issue</a>。</p>
<p>这是 TypeScript 1.7 新增的类型。</p>
<p><code>this</code> 类型可以用在 classes 和 interfaces 里，表示某种类型，它是 containing type 的 subtype（而不是 containing type）。</p>
<p>关于多态这个计算机科学词汇，这里加深下理解。</p>
<p>我们先以 <a href="https://msdn.microsoft.com/zh-cn/library/ms173152.aspx" target="_blank" rel="external">C#中的多态性为例</a> 理解：</p>
<p>多态指两个方面：</p>
<ul>
<li>运行时，在 方法参数、集合或数组等位置，派生类的对象可以作为基类的对象处理。即，对象的声明类型不再与运行时相同。</li>
<li>基类可以定义并实现虚方法，派生类可以重写（override）这些方法，即派生类提供自己的定义和实现。运行时，CLR 查找对象的<strong>运行时</strong>定义，调用虚方法的重写方法。即，你可以调用基类的方法，但执行的是派生类版本。</li>
</ul>
<p>这些是在 C# 中的实践，再来看下<a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%9E%8B_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6" target="_blank" rel="external">维基百科</a>的定义：</p>
<blockquote>
<p>多态，是指计算机程序运行时，相同的消息可能会送给多个不同的类之对象，而系统可依据对象所属类，引发对应类的方法，而有不同的行为。<br>多态也可定义为“一种将不同的特殊行为和单个泛化记号相关联的能力”。</p>
</blockquote>
<p>这里先重点关于下<strong>动态多态（dynamic polymorphism）</strong>：通过类继承机制和虚函数机制生效于运行期。可以优雅地处理异质对象集合，只要其共同的基类定义了虚函数的接口。也被称为子类型多态（Subtype polymorphism）或包含多态（inclusion polymorphism）。在面向对象程序设计中，这被直接称为多态。</p>
<p>另外提及一点，静态多态中的参数化多态（Parametric polymorphism），把类型作为参数的多态。在面向对象程序设计中，这被称作<a href="https://zh.wikipedia.org/wiki/%E6%B3%9B%E5%9E%8B" target="_blank" rel="external">泛型编程</a>。</p>
<p>现在回头再看下 TypeScript 1.7 引入的多态 <code>this</code> 类型：</p>
<blockquote>
<p><code>this</code> 类型可以用在 classes 和 interfaces 里，表示某种类型，它是 containing type 的 subtype（而不是 containing type）。</p>
</blockquote>
<p>这个特性可以帮助容易写出某些 patterns，比如：hierachical fluent APIs，层级流式 API。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="interface"><span class="keyword">interface</span> Model </span>&#123;</span><br><span class="line">    setupBase(): <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="interface"><span class="keyword">interface</span> AdvancedModel <span class="keyword">extends</span> Model </span>&#123;</span><br><span class="line">    setupAdvanced(): <span class="keyword">this</span>;  <span class="comment">// 返回值是 this，这个 this 既可以是指本身，也可以指基类</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">createModel</span>(<span class="params"></span>): <span class="title">AdvancedModel</span></span>;</span><br><span class="line">newModel = newModel.setupBase().setupAdvanced(); <span class="comment">// fluent style works</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>问：TypeScript 中的 <code>declare</code> 关键词是指？</p>
</blockquote>
<p>关于 <code>this</code> 的更多信息，参考 <a href="https://github.com/Microsoft/TypeScript/wiki/What%27s-new-in-TypeScript#this-typing" target="_blank" rel="external">TypeScript Wiki</a>。</p>
<p>为了支持这个特性，TypeScript 1.7 对从 <code>this</code> 推导（inferring）type 做了些许变更。大致一些<a href="https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#TypeScript1.7" target="_blank" rel="external">潜在的 breaking changes</a>：</p>
<blockquote>
<p>In a class, the type of the value this will be inferred to the this type, and subsequent assignments from values of the original type can fail. As a workaround, you could add a type annotation for this. A code sample with recommended work around, along with a list of other potentially breaking changes is available at GitHub.</p>
</blockquote>
<h2 id="ES6_Module_Emitting"><a href="#ES6_Module_Emitting" class="headerlink" title="ES6 Module Emitting"></a>ES6 Module Emitting</h2><p>Node.js v4+，支持很多 ES6 特性，但是不支持 ES6 modules，可以如下配置，适应 Node.js v4+ 的 runtime。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//tsconfig.json targeting node.js v4 and beyond</span><br><span class="line">&#123;</span><br><span class="line">    "compilerOptions": &#123;</span><br><span class="line">        "module": "commonjs",</span><br><span class="line">        "target": "es6"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ES7_Exponentiation"><a href="#ES7_Exponentiation" class="headerlink" title="ES7 Exponentiation"></a>ES7 Exponentiation</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> squared = <span class="number">2</span> ** <span class="number">2</span>;  <span class="comment">// same as: 2 * 2</span></span><br><span class="line"><span class="keyword">let</span> cubed = <span class="number">2</span> ** <span class="number">3</span>;  <span class="comment">// same as: 2 * 2 * 2</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">2</span>;</span><br><span class="line">num **= <span class="number">2</span>; <span class="comment">// same as: num = num * num;</span></span><br></pre></td></tr></table></figure>
<p>和 <code>Math.pow()</code> 说 Byebye。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/01/13/scaffold-and-tools-for-front-end-will-update-regularly/" class="prev">上一篇</a><a href="/2015/12/21/hello-world/" class="next">下一篇</a></div></footer><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>