<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> immutable-js 入门 · Shane Hsi Rocks</title><meta name="description" content="Immutable collections for JavaScript
Immutable data cannot be changed once created, leading to much simplerapplication development, no defensive copying, and ena"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="https://github.com/shane13hsi" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">immutable-js 入门</h1><div class="post-meta"><div class="post-time">Mar 15, 2016</div></div><div class="post-content"><h1 id="Immutable_collections_for_JavaScript"><a href="#Immutable_collections_for_JavaScript" class="headerlink" title="Immutable collections for JavaScript"></a>Immutable collections for JavaScript</h1><p><a href="https://travis-ci.org/facebook/immutable-js" target="_blank" rel="external"><img src="https://travis-ci.org/facebook/immutable-js.svg" alt="Build Status"></a></p>
<p><a href="http://en.wikipedia.org/wiki/Immutable_object" target="_blank" rel="external">Immutable</a> data cannot be changed once created, leading to much simpler<br>application development, no defensive copying, and enabling advanced memoization<br>and change detection techniques with simple logic. <a href="http://en.wikipedia.org/wiki/Persistent_data_structure" target="_blank" rel="external">Persistent</a> data presents<br>a mutative API which does not update the data in-place, but instead always<br>yields new updated data.</p>
<p>简化开发流程：</p>
<ul>
<li>不会出现防守型复制（defensive copying）。</li>
<li>可以进行高级的记忆（memoization）</li>
<li>简化变动监测（change detection）</li>
</ul>
<p>持久化（Persistent）data 提供了可变的 API ，不会更新 data，而是总是生成新的更新过的数据。</p>
<p>Immutable.js provides many Persistent Immutable data structures including:<br><code>List</code>, <code>Stack</code>, <code>Map</code>, <code>OrderedMap</code>, <code>Set</code>, <code>OrderedSet</code> and <code>Record</code>.</p>
<p>所以，提供的是：</p>
<p><strong> Persistent Immutable data structures </strong>，持久化不可变数据结构</p>
<p>包括： <code>List</code>，<code>Stack</code>，<code>Map</code>，<code>OrderedMap</code>，<code>Set</code>，<code>OrderedSet</code> 和 <code>Record</code>。</p>
<p>These data structures are highly efficient on modern JavaScript VMs by using<br>structural sharing via <a href="http://en.wikipedia.org/wiki/Hash_array_mapped_trie" target="_blank" rel="external">hash maps tries</a> and <a href="http://hypirion.com/musings/understanding-persistent-vector-pt-1" target="_blank" rel="external">vector tries</a> as popularized<br>by Clojure and Scala, minimizing the need to copy or cache data.</p>
<p>在现代的 JavaScript VMs 是非常高效的（通过使用 structural sharing，后者又是基于 hash map tries，和 vector tries，这些概念是因 Closure 和 Scala 流行的）。减少了复制或者缓存数据的需求。</p>
<p><code>Immutable</code> also provides a lazy <code>Seq</code>, allowing efficient<br>chaining of collection methods like <code>map</code> and <code>filter</code> without creating<br>intermediate representations. Create some <code>Seq</code> with <code>Range</code> and <code>Repeat</code>.</p>
<p>同时也提供了 lazy <code>Seq</code>，可以允许集合方法高效的 chaining，比如 <code>map</code>，<code>filter</code>，不用创造中介的展示。</p>
<h2 id="Getting_started"><a href="#Getting_started" class="headerlink" title="Getting started"></a>Getting started</h2><p>Install <code>immutable</code> using npm.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install immutable</span><br></pre></td></tr></table></figure>
<p>Then require it into any module.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Immutable = <span class="built_in">require</span>(<span class="string">'immutable'</span>);</span><br><span class="line"><span class="keyword">var</span> map1 = Immutable.Map(&#123;a:<span class="number">1</span>, b:<span class="number">2</span>, c:<span class="number">3</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> map2 = map1.set(<span class="string">'b'</span>, <span class="number">50</span>);</span><br><span class="line">map1.get(<span class="string">'b'</span>); <span class="comment">// 2</span></span><br><span class="line">map2.get(<span class="string">'b'</span>); <span class="comment">// 50</span></span><br></pre></td></tr></table></figure>
<h3 id="Browser"><a href="#Browser" class="headerlink" title="Browser"></a>Browser</h3><p>To use <code>immutable</code> from a browser, download <a href="https://github.com/facebook/immutable-js/blob/master/dist/immutable.min.js" target="_blank" rel="external">dist/immutable.min.js</a><br>or use a CDN such as <a href="https://cdnjs.com/libraries/immutable" target="_blank" rel="external">CDNJS</a><br>or <a href="http://www.jsdelivr.com/#!immutable.js" target="_blank" rel="external">jsDelivr</a>.</p>
<p>Then, add it as a script tag to your page:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"immutable.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="actionscript"></span><br><span class="line">    <span class="keyword">var</span> map1 = Immutable.Map(&#123;a:<span class="number">1</span>, b:<span class="number">2</span>, c:<span class="number">3</span>&#125;);</span><br><span class="line">    <span class="keyword">var</span> map2 = map1.<span class="keyword">set</span>(<span class="string">'b'</span>, <span class="number">50</span>);</span><br><span class="line">    map1.<span class="keyword">get</span>(<span class="string">'b'</span>); <span class="comment">// 2</span></span><br><span class="line">    map2.<span class="keyword">get</span>(<span class="string">'b'</span>); <span class="comment">// 50</span></span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Or use an AMD loader (such as <a href="http://requirejs.org/" target="_blank" rel="external">RequireJS</a>):</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">'./immutable.min.js'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">Immutable</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> map1 = Immutable.Map(&#123;a:<span class="number">1</span>, b:<span class="number">2</span>, c:<span class="number">3</span>&#125;);</span><br><span class="line">    <span class="keyword">var</span> map2 = map1.set(<span class="string">'b'</span>, <span class="number">50</span>);</span><br><span class="line">    map1.get(<span class="string">'b'</span>); <span class="comment">// 2</span></span><br><span class="line">    map2.get(<span class="string">'b'</span>); <span class="comment">// 50</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>If you’re using <a href="http://browserify.org/" target="_blank" rel="external">browserify</a>, the <code>immutable</code> npm module<br>also works from the browser.</p>
<h3 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h3><p>Use these Immutable collections and sequences as you would use native<br>collections in your <a href="http://typescriptlang.org" target="_blank" rel="external">TypeScript</a> programs while still taking<br>advantage of type generics, error detection, and auto-complete in your IDE.</p>
<p>Just add a reference with a relative path to the type declarations at the top<br>of your file.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///&lt;reference path='./node_modules/immutable/dist/immutable.d.ts'/&gt;</span></span><br><span class="line"><span class="keyword">import</span> Immutable = require(<span class="string">'immutable'</span>);</span><br><span class="line"><span class="keyword">var</span> map1: Immutable.Map&lt;string, number&gt;;</span><br><span class="line">map1 = Immutable.Map(&#123;a:<span class="number">1</span>, b:<span class="number">2</span>, c:<span class="number">3</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> map2 = map1.set(<span class="string">'b'</span>, <span class="number">50</span>);</span><br><span class="line">map1.get(<span class="string">'b'</span>); <span class="comment">// 2</span></span><br><span class="line">map2.get(<span class="string">'b'</span>); <span class="comment">// 50</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>Map</code> 是数据结构。</p>
<p><code>set</code> 设置 key，<code>get</code> 获取 key。</p>
<h2 id="The_case_for_Immutability"><a href="#The_case_for_Immutability" class="headerlink" title="The case for Immutability"></a>The case for Immutability</h2><p>Much of what makes application development difficult is tracking mutation and<br>maintaining state. Developing with immutable data encourages you to think<br>differently about how data flows through your application.</p>
<p>应用开发之所以复杂，在于要跟踪 变动（tracking mutations），维护状态。</p>
<p>使用 immutable data 可以鼓励从不同的角度看 data flows。</p>
<p>Subscribing to data events throughout your application creates a huge overhead of<br>book-keeping which can hurt performance, sometimes dramatically, and creates<br>opportunities for areas of your application to get out of sync with each other<br>due to easy to make programmer error. Since immutable data never changes,<br>subscribing to changes throughout the model is a dead-end and new data can only<br>ever be passed from above.</p>
<ul>
<li>订阅 data events 会创建很多记忆（book-keeping）负担，影响到性能，有时是严重性的。</li>
<li>分布在多个区块的数据可能会不一致</li>
<li>由于 immutable data 会可变，所以，订阅 data evetns 是死路。</li>
</ul>
<p>This model of data flow aligns well with the architecture of <a href="http://facebook.github.io/react/" target="_blank" rel="external">React</a><br>and especially well with an application designed using the ideas of <a href="http://facebook.github.io/flux/docs/overview.html" target="_blank" rel="external">Flux</a>.</p>
<p>这种 data flows 也催生出了 react 以及 flux 的设计</p>
<p>When data is passed from above rather than being subscribed to, and you’re only<br>interested in doing work when something has changed, you can use equality.</p>
<p>数据是 passed，不是 subscribed。</p>
<p>Immutable collections should be treated as <em>values</em> rather than <em>objects</em>. While<br>objects represents some thing which could change over time, a value represents<br>the state of that thing at a particular instance of time. This principle is most<br>important to understanding the appropriate use of immutable data. In order to<br>treat Immutable.js collections as values, it’s important to use the<br><code>Immutable.is()</code> function or <code>.equals()</code> method to determine value equality<br>instead of the <code>===</code> operator which determines object reference identity.</p>
<p>Immutable 集合应该当做 <em>values</em>，而不是 <em>objects</em>。值不会变，代表着一个时间的一个实例。</p>
<p>所以，objects 相关的都不要用。</p>
<p>要用：</p>
<p><code>Immutable.is()</code> 或者 <code>equals()</code> 方法，不要用 <code>===</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map1 = Immutable.Map(&#123;a:<span class="number">1</span>, b:<span class="number">2</span>, c:<span class="number">3</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> map2 = map1.set(<span class="string">'b'</span>, <span class="number">2</span>);</span><br><span class="line">assert(map1.equals(map2) === <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">var</span> map3 = map1.set(<span class="string">'b'</span>, <span class="number">50</span>);</span><br><span class="line">assert(map1.equals(map3) === <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>Note: As a performance optimization <code>Immutable</code> attempts to return the existing<br>collection when an operation would result in an identical collection, allowing<br>for using <code>===</code> reference equality to determine if something definitely has not<br>changed. This can be extremely useful when used within memoization function<br>which would prefer to re-run the function if a deeper equality check could<br>potentially be more costly. The <code>===</code> equality check is also used internally by<br><code>Immutable.is</code> and <code>.equals()</code> as a performance optimization.</p>
<p>注意：性能优化原因，有时 <code>Immutable</code> 会返回一样的 collection（如果从值上看一样的话），这时候 <code>===</code> 的结果也是对的。<br>这个在 memoization function 运行 deep equality check 很有用，更简单了。</p>
<blockquote>
<p>注意：这里的 memoization function 就是 <code>shouldComponentUpdate</code>。</p>
</blockquote>
<p>If an object is immutable, it can be “copied” simply by making another reference<br>to it instead of copying the entire object. Because a reference is much smaller<br>than the object itself, this results in memory savings and a potential boost in<br>execution speed for programs which rely on copies (such as an undo-stack).</p>
<p>如果 object 是 immutable，就可以很简单的 copy，只要新建一个 reference，而不是复制整个对象。</p>
<p>reference 很小。也简化了内存，可能也会对依赖复制的应用增加执行速度。</p>
<p>这里的 copy，就是通过 <code>=</code>（赋值运算符）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map1 = Immutable.Map(&#123;a:<span class="number">1</span>, b:<span class="number">2</span>, c:<span class="number">3</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> clone = map1;</span><br></pre></td></tr></table></figure>
<h2 id="JavaScript-first_API"><a href="#JavaScript-first_API" class="headerlink" title="JavaScript-first API"></a>JavaScript-first API</h2><p>While <code>immutable</code> is inspired by Clojure, Scala, Haskell and other functional<br>programming environments, it’s designed to bring these powerful concepts to<br>JavaScript, and therefore has an Object-Oriented API that closely mirrors that<br>of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_6_support_in_Mozilla" target="_blank" rel="external">ES6</a> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="external">Array</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" target="_blank" rel="external">Map</a>, and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set" target="_blank" rel="external">Set</a>.</p>
<p>尽量接近 JavaScript 的标准。提供了镜像 Array，Map，Set 的面向对象的 API。</p>
<p>The difference for the immutable collections is that methods which would mutate<br>the collection, like <code>push</code>, <code>set</code>, <code>unshift</code> or <code>splice</code> instead return a new<br>immutable collection. Methods which return new arrays like <code>slice</code> or <code>concat</code><br>instead return new immutable collections.</p>
<p>区别是，<code>push</code>，<code>set</code>，<code>unshift</code>，<code>splice</code> 不会更改集合，而是返回一个系你的 immutable collection。</p>
<p>像 <code>slice</code> 和 <code>concat</code> 之前返回新的 arrays，会返回新的 immutable collections。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list1 = Immutable.List.of(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> list2 = list1.push(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">var</span> list3 = list2.unshift(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">var</span> list4 = list1.concat(list2, list3);</span><br><span class="line">assert(list1.size === <span class="number">2</span>);</span><br><span class="line">assert(list2.size === <span class="number">5</span>);</span><br><span class="line">assert(list3.size === <span class="number">6</span>);</span><br><span class="line">assert(list4.size === <span class="number">13</span>);</span><br><span class="line">assert(list4.get(<span class="number">0</span>) === <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>Almost all of the methods on <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="external">Array</a> will be found in similar form on<br><code>Immutable.List</code>, those of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" target="_blank" rel="external">Map</a> found on <code>Immutable.Map</code>, and those of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set" target="_blank" rel="external">Set</a><br>found on <code>Immutable.Set</code>, including collection operations like <code>forEach()</code><br>and <code>map()</code>.</p>
<p>Array -&gt; Immuable.List<br>Map -&gt; Immutable.Map<br>Set -&gt; Immutable.Set</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> alpha = Immutable.Map(&#123;a:<span class="number">1</span>, b:<span class="number">2</span>, c:<span class="number">3</span>, d:<span class="number">4</span>&#125;);</span><br><span class="line">alpha.map((v, k) =&gt; k.toUpperCase()).join();</span><br><span class="line"><span class="comment">// 'A,B,C,D'</span></span><br></pre></td></tr></table></figure>
<h3 id="Accepts_raw_JavaScript_objects"><a href="#Accepts_raw_JavaScript_objects" class="headerlink" title="Accepts raw JavaScript objects."></a>Accepts raw JavaScript objects.</h3><p>Designed to inter-operate with your existing JavaScript, <code>immutable</code><br>accepts plain JavaScript Arrays and Objects anywhere a method expects an<br><code>Iterable</code> with no performance penalty.</p>
<p>因为要和 JavaScript 代码交互，所以 <code>immutable</code> 可以接受 plain JavaScriptJavaScript Arrays 和 Objects（可以接收 <code>Iterable</code> 的方法）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map1 = Immutable.Map(&#123;a:<span class="number">1</span>, b:<span class="number">2</span>, c:<span class="number">3</span>, d:<span class="number">4</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> map2 = Immutable.Map(&#123;c:<span class="number">10</span>, a:<span class="number">20</span>, t:<span class="number">30</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> obj = &#123;d:<span class="number">100</span>, o:<span class="number">200</span>, g:<span class="number">300</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> map3 = map1.merge(map2, obj);</span><br><span class="line"><span class="comment">// Map &#123; a: 20, b: 2, c: 10, d: 100, t: 30, o: 200, g: 300 &#125;</span></span><br></pre></td></tr></table></figure>
<p>This is possible because <code>immutable</code> can treat any JavaScript Array or Object<br>as an Iterable. You can take advantage of this in order to get sophisticated<br>collection methods on JavaScript Objects, which otherwise have a very sparse<br>native API. Because Seq evaluates lazily and does not cache intermediate<br>results, these operations can be extremely efficient.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;a:<span class="number">1</span>,b:<span class="number">2</span>,c:<span class="number">3</span>&#125;;</span><br><span class="line">Immutable.Seq(myObject).map(x =&gt; x * x).toObject();</span><br><span class="line"><span class="comment">// &#123; a: 1, b: 4, c: 9 &#125;</span></span><br></pre></td></tr></table></figure>
<p>Keep in mind, when using JS objects to construct Immutable Maps, that<br>JavaScript Object properties are always strings, even if written in a quote-less<br>shorthand, while Immutable Maps accept keys of any type.</p>
<p>记住一点，构造成 immutable 所有的 key 都会变成 string。即 <code>.get(key: string)</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="number">1</span>: <span class="string">"one"</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.keys(obj); <span class="comment">// [ "1" ]</span></span><br><span class="line">obj[<span class="string">"1"</span>]; <span class="comment">// "one"</span></span><br><span class="line">obj[<span class="number">1</span>];   <span class="comment">// "one"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> map = Immutable.fromJS(obj);</span><br><span class="line">map.get(<span class="string">"1"</span>); <span class="comment">// "one"</span></span><br><span class="line">map.get(<span class="number">1</span>);   <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>Property access for JavaScript Objects first converts the key to a string, but<br>since Immutable Map keys can be of any type the argument to <code>get()</code> is<br>not altered.</p>
<h3 id="Converts_back_to_raw_JavaScript_objects"><a href="#Converts_back_to_raw_JavaScript_objects" class="headerlink" title="Converts back to raw JavaScript objects."></a>Converts back to raw JavaScript objects.</h3><p>All <code>immutable</code> Iterables can be converted to plain JavaScript Arrays and<br>Objects shallowly with <code>toArray()</code> and <code>toObject()</code> or deeply with <code>toJS()</code>.<br>All Immutable Iterables also implement <code>toJSON()</code> allowing them to be passed to<br><code>JSON.stringify</code> directly.</p>
<p>变回 raw JavaScript objects。</p>
<p><code>toArray()</code>，<code>toObject()</code>，<code>toJS()</code>。</p>
<p><code>toJSON()</code>，可以直接传递给 <code>JSON.stringify</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deep = Immutable.Map(&#123; a: <span class="number">1</span>, b: <span class="number">2</span>, c: Immutable.List.of(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) &#125;);</span><br><span class="line">deep.toObject() <span class="comment">// &#123; a: 1, b: 2, c: List [ 3, 4, 5 ] &#125;</span></span><br><span class="line">deep.toArray() <span class="comment">// [ 1, 2, List [ 3, 4, 5 ] ]</span></span><br><span class="line">deep.toJS() <span class="comment">// &#123; a: 1, b: 2, c: [ 3, 4, 5 ] &#125;</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(deep) <span class="comment">// '&#123;"a":1,"b":2,"c":[3,4,5]&#125;'</span></span><br></pre></td></tr></table></figure>
<h3 id="Embraces_ES6"><a href="#Embraces_ES6" class="headerlink" title="Embraces ES6"></a>Embraces ES6</h3><p><code>Immutable</code> takes advantage of features added to JavaScript in <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_6_support_in_Mozilla" target="_blank" rel="external">ES6</a>,<br>the latest standard version of ECMAScript (JavaScript), including <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/The_Iterator_protocol" target="_blank" rel="external">Iterators</a>,<br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="external">Arrow Functions</a>, <a href="http://wiki.ecmascript.org/doku.php?id=strawman:maximally_minimal_classes" target="_blank" rel="external">Classes</a>, and <a href="http://www.2ality.com/2014/09/es6-modules-final.html" target="_blank" rel="external">Modules</a>. It’s also inspired by the<br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" target="_blank" rel="external">Map</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set" target="_blank" rel="external">Set</a> collections added to ES6. The library is “transpiled” to ES3<br>in order to support all modern browsers.</p>
<p>All examples are presented in ES6. To run in all browsers, they need to be<br>translated to ES3.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6</span></span><br><span class="line">foo.map(x =&gt; x * x);</span><br><span class="line"><span class="comment">// ES3</span></span><br><span class="line">foo.map(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x * x; &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="Nested_Structures"><a href="#Nested_Structures" class="headerlink" title="Nested Structures"></a>Nested Structures</h2><p>The collections in <code>immutable</code> are intended to be nested, allowing for deep<br>trees of data, similar to JSON.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nested = Immutable.fromJS(&#123;a:&#123;b:&#123;c:[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]&#125;&#125;&#125;);</span><br><span class="line"><span class="comment">// Map &#123; a: Map &#123; b: Map &#123; c: List [ 3, 4, 5 ] &#125; &#125; &#125;</span></span><br></pre></td></tr></table></figure>
<p>A few power-tools allow for reading and operating on nested data. The<br>most useful are <code>mergeDeep</code>, <code>getIn</code>, <code>setIn</code>, and <code>updateIn</code>, found on <code>List</code>,<br><code>Map</code> and <code>OrderedMap</code>.</p>
<p>这是一些帮助方法，可以帮助读取，操作嵌套结构。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nested2 = nested.mergeDeep(&#123;a:&#123;b:&#123;d:<span class="number">6</span>&#125;&#125;&#125;);</span><br><span class="line"><span class="comment">// Map &#123; a: Map &#123; b: Map &#123; c: List [ 3, 4, 5 ], d: 6 &#125; &#125; &#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nested2.getIn([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'d'</span>]); <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nested3 = nested2.updateIn([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'d'</span>], value =&gt; value + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// Map &#123; a: Map &#123; b: Map &#123; c: List [ 3, 4, 5 ], d: 7 &#125; &#125; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nested4 = nested3.updateIn([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], list =&gt; list.push(<span class="number">6</span>));</span><br><span class="line"><span class="comment">// Map &#123; a: Map &#123; b: Map &#123; c: List [ 3, 4, 5, 6 ], d: 7 &#125; &#125; &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="Lazy_Seq"><a href="#Lazy_Seq" class="headerlink" title="Lazy Seq"></a>Lazy Seq</h2><p><code>Seq</code> describes a lazy operation, allowing them to efficiently chain<br>use of all the Iterable methods (such as <code>map</code> and <code>filter</code>).</p>
<p><strong>Seq is immutable</strong> — Once a Seq is created, it cannot be<br>changed, appended to, rearranged or otherwise modified. Instead, any mutative<br>method called on a Seq will return a new Seq.</p>
<p><strong>Seq is lazy</strong> — Seq does as little work as necessary to respond to any<br>method call.</p>
<p>For example, the following does not perform any work, because the resulting<br>Seq is never used:</p>
<pre><code>var oddSquares = Immutable.Seq.of(1,2,3,4,5,6,7,8)
  .filter(x =&gt; x % 2).map(x =&gt; x * x);
</code></pre><p>Once the Seq is used, it performs only the work necessary. In this<br>example, no intermediate arrays are ever created, filter is called three times,<br>and map is only called twice:</p>
<pre><code>console.log(oddSquares.get(1)); // 9
</code></pre><p>Any collection can be converted to a lazy Seq with <code>.toSeq()</code>.</p>
<pre><code>var seq = Immutable.Map({a:1, b:1, c:1}).toSeq();
</code></pre><p>Seq allow for the efficient chaining of sequence operations, especially when<br>converting to a different concrete type (such as to a JS object):</p>
<pre><code>seq.flip().map(key =&gt; key.toUpperCase()).flip().toObject();
// Map { A: 1, B: 1, C: 1 }
</code></pre><p>As well as expressing logic that would otherwise seem memory-limited:</p>
<pre><code>Immutable.Range(1, Infinity)
  .skip(1000)
  .map(n =&gt; -n)
  .filter(n =&gt; n % 2 === 0)
  .take(2)
  .reduce((r, n) =&gt; r * n, 1);
// 1006008
</code></pre><p>Note: An iterable is always iterated in the same order, however that order may<br>not always be well defined, as is the case for the <code>Map</code>.</p>
<h2 id="Equality_treats_Collections_as_Data"><a href="#Equality_treats_Collections_as_Data" class="headerlink" title="Equality treats Collections as Data"></a>Equality treats Collections as Data</h2><p><code>Immutable</code> provides equality which treats immutable data structures as pure<br>data, performing a deep equality check if necessary.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map1 = Immutable.Map(&#123;a:<span class="number">1</span>, b:<span class="number">1</span>, c:<span class="number">1</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> map2 = Immutable.Map(&#123;a:<span class="number">1</span>, b:<span class="number">1</span>, c:<span class="number">1</span>&#125;);</span><br><span class="line">assert(map1 !== map2); <span class="comment">// two different instances</span></span><br><span class="line">assert(Immutable.is(map1, map2)); <span class="comment">// have equivalent values</span></span><br><span class="line">assert(map1.equals(map2)); <span class="comment">// alternatively use the equals method</span></span><br></pre></td></tr></table></figure>
<p><code>Immutable.is()</code> uses the same measure of equality as <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is" target="_blank" rel="external">Object.is</a><br>including if both are immutable and all keys and values are equal<br>using the same measure of equality.</p>
<h2 id="Batching_Mutations"><a href="#Batching_Mutations" class="headerlink" title="Batching Mutations"></a>Batching Mutations</h2><blockquote>
<p>If a tree falls in the woods, does it make a sound?</p>
<p>If a pure function mutates some local data in order to produce an immutable<br>return value, is that ok?</p>
<p>— Rich Hickey, Clojure</p>
</blockquote>
<p>Applying a mutation to create a new immutable object results in some overhead,<br>which can add up to a minor performance penalty. If you need to apply a series<br>of mutations locally before returning, <code>Immutable</code> gives you the ability to<br>create a temporary mutable (transient) copy of a collection and apply a batch of<br>mutations in a performant manner by using <code>withMutations</code>. In fact, this is<br>exactly how  <code>Immutable</code> applies complex mutations itself.</p>
<p>As an example, building <code>list2</code> results in the creation of 1, not 3, new<br>immutable Lists.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list1 = Immutable.List.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> list2 = list1.withMutations(<span class="function"><span class="keyword">function</span> (<span class="params">list</span>) </span>&#123;</span><br><span class="line">  list.push(<span class="number">4</span>).push(<span class="number">5</span>).push(<span class="number">6</span>);</span><br><span class="line">&#125;);</span><br><span class="line">assert(list1.size === <span class="number">3</span>);</span><br><span class="line">assert(list2.size === <span class="number">6</span>);</span><br></pre></td></tr></table></figure>
<p>Note: <code>immutable</code> also provides <code>asMutable</code> and <code>asImmutable</code>, but only<br>encourages their use when <code>withMutations</code> will not suffice. Use caution to not<br>return a mutable copy, which could result in undesired behavior.</p>
<p><em>Important!</em>: Only a select few methods can be used in <code>withMutations</code> including<br><code>set</code>, <code>push</code> and <code>pop</code>. These methods can be applied directly against a<br>persistent data-structure where other methods like <code>map</code>, <code>filter</code>, <code>sort</code>,<br>and <code>splice</code> will always return new immutable data-structures and never mutate<br>a mutable collection.</p>
<h2 id="Documentation"><a href="#Documentation" class="headerlink" title="Documentation"></a>Documentation</h2><p><a href="http://facebook.github.io/immutable-js/docs/" target="_blank" rel="external">Read the docs</a> and eat your vegetables.</p>
<p>Docs are automatically generated from <a href="https://github.com/facebook/immutable-js/blob/master/type-definitions/Immutable.d.ts" target="_blank" rel="external">Immutable.d.ts</a>.<br>Please contribute!</p>
<p>Also, don’t miss the <a href="https://github.com/facebook/immutable-js/wiki" target="_blank" rel="external">Wiki</a> which<br>contains articles on specific topics. Can’t find something? Open an <a href="https://github.com/facebook/immutable-js/issues" target="_blank" rel="external">issue</a>.</p>
<h2 id="Contribution"><a href="#Contribution" class="headerlink" title="Contribution"></a>Contribution</h2><p>Use <a href="https://github.com/facebook/immutable-js/issues" target="_blank" rel="external">Github issues</a> for requests.</p>
<p>We actively welcome pull requests, learn how to <a href="./CONTRIBUTING.md">contribute</a>.</p>
<h2 id="Changelog"><a href="#Changelog" class="headerlink" title="Changelog"></a>Changelog</h2><p>Changes are tracked as <a href="https://github.com/facebook/immutable-js/releases" target="_blank" rel="external">Github releases</a>.</p>
<h2 id="Thanks"><a href="#Thanks" class="headerlink" title="Thanks"></a>Thanks</h2><p><a href="https://www.youtube.com/watch?v=K2NYwP90bNs" target="_blank" rel="external">Phil Bagwell</a>, for his inspiration<br>and research in persistent data structures.</p>
<p><a href="https://github.com/hughfdjackson/" target="_blank" rel="external">Hugh Jackson</a>, for providing the npm package<br>name. If you’re looking for his unsupported package, see <a href="https://www.npmjs.org/package/immutable/1.4.1" target="_blank" rel="external">v1.4.1</a>.</p>
<h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p><code>Immutable</code> is <a href="./LICENSE">BSD-licensed</a>. We also provide an additional <a href="./PATENTS">patent grant</a>.</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/03/15/Redux-APIs/" class="prev">上一篇</a><a href="/2016/03/14/Redux-multiple-stores-why-not/" class="next">下一篇</a></div></footer><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>