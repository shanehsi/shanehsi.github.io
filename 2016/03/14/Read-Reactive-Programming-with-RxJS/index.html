<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Reactive Programming with RxJS - 笔记 · Shane Hsi Rocks</title><meta name="description" content="Untangle Your Asynchronous JavaScript Code

events happen in random order 事件不同顺序，就要管理事件applications crash 就要重启networks fails 就要重试Few applications are completely synchronous 现状 need super-fast responses and  异步，快速响应。the ability to process data from different sources at the same time without missing a beat. 同时处理多个源的数据的能力，不丢失。code becomes expo- nentially more complex as we add concurrency and application state. 引入并发和应用状态，程序变非常复杂。

&lt;a href=&quot;#Ch1_-_The_Reactive_Way&quot; class=&quot;headerlink&quot; title=&quot;Ch1 - The Rea"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="https://github.com/shane13hsi" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Reactive Programming with RxJS - 笔记</h1><div class="post-meta"><div class="post-time">Mar 14, 2016</div></div><div class="post-content"><p>Untangle Your Asynchronous JavaScript Code</p>
<blockquote>
<p>events happen in random order 事件不同顺序，就要管理事件<br>applications crash 就要重启<br>networks fails 就要重试<br>Few applications are completely synchronous 现状<br> need super-fast responses and  异步，快速响应。<br>the ability to process data from different sources at the same time without missing a beat. 同时处理多个源的数据的能力，不丢失。<br>code becomes expo- nentially more complex as we add concurrency and application state. 引入并发和应用状态，程序变非常复杂。</p>
</blockquote>
<h2 id="Ch1_-_The_Reactive_Way"><a href="#Ch1_-_The_Reactive_Way" class="headerlink" title="Ch1 - The Reactive Way"></a>Ch1 - The Reactive Way</h2><p>多个源头</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById(<span class="string">'retrieveDataBtn'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> source1 = Rx.DOM.getJSON(<span class="string">'/resource1'</span>).pluck(<span class="string">'name'</span>);</span><br><span class="line"><span class="keyword">var</span> source2 = Rx.DOM.getJSON(<span class="string">'/resource2'</span>).pluck(<span class="string">'props'</span>, <span class="string">'name'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getResults</span>(<span class="params">amount</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> source1.merge(source2)</span><br><span class="line">        .pluck(<span class="string">'names'</span>)</span><br><span class="line">        .flatMap(<span class="function"><span class="keyword">function</span>(<span class="params">array</span>) </span>&#123; <span class="keyword">return</span> Rx.Observable.from(array); &#125;</span><br><span class="line">            ).distinct()</span><br><span class="line">        .take(amount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> clicks = Rx.Observable.fromEvent(button, <span class="string">'click'</span>);</span><br><span class="line"></span><br><span class="line">clicks.debounce(<span class="number">1000</span>)</span><br><span class="line">    .flatMap(getResults(<span class="number">5</span>))</span><br><span class="line">    .subscribe(</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'Received value'</span>, value); &#125;,</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123; <span class="built_in">console</span>.error(err); &#125;,</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'All values retrieved!'</span>); &#125;</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<p>重点：</p>
<ul>
<li>pluck 来做摘取</li>
<li>merge 来合并</li>
<li>flatMap 来展平</li>
<li>distinct 进行去重</li>
<li>take 取样</li>
<li>debounce 防抖</li>
<li>subscribe 订阅</li>
</ul>
<p>An Observable represents a stream of data.</p>
<p>再强调：Observable，可被观察到的事物。</p>
<p>这里面：</p>
<ul>
<li>两个 remote source 是 Observable</li>
<li>mouse clicks 是 Observable</li>
</ul>
<blockquote>
<p>后面会看到，<code>Subject</code> 可以做 proxy。方便构建架构。</p>
</blockquote>
<p><code>Rx.Observable.create</code></p>
<h2 id="Ch_2_-_Deep_in_the_Sequence"><a href="#Ch_2_-_Deep_in_the_Sequence" class="headerlink" title="Ch 2 - Deep in the Sequence"></a>Ch 2 - Deep in the Sequence</h2><ul>
<li>map</li>
<li>filter</li>
<li>reduce</li>
<li>flatMap 表达式这样： O[O1, O2, O3]</li>
</ul>
<img src="/2016/03/14/Read-Reactive-Programming-with-RxJS/flatMap.png" alt="FlatMap" title="FlatMap">
<p>| from | Synchronous | 从 arrays 和 iterables |<br>| range | Sync | |<br>| interval | Async | 时间间隔生成值 |<br>| distinct | Same as | | </p>
<h3 id="RxJS_u2019s_Subject_Class"><a href="#RxJS_u2019s_Subject_Class" class="headerlink" title="RxJS’s Subject Class"></a>RxJS’s Subject Class</h3><p>A Subject is a type that implements both Observer and Observable types. As an Observer, it can subscribe to Observables, and as an Observable it can produce values and have Observers subscribe to it.</p>
<p>In some scenarios a single Subject can do the work of a combination of Observers and Observables. For example, for making a proxy object between a data source and the Subject’s listeners, we could use this:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> subject = <span class="keyword">new</span> Rx.Subject();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">300</span>)</span><br><span class="line">    .map(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Interval message #'</span> + v; &#125;).take(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">source.subscribe(subject);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> subscription = subject.subscribe(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onNext</span>(<span class="params">x</span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'onNext: '</span> + x); &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onError</span>(<span class="params">e</span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'onError: '</span> + e.message); &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onCompleted</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'onCompleted'</span>); &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">'Our message #1'</span>);</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">'Our message #2'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    subject.onCompleted();</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>In the preceding example we create a <strong>new Subject</strong> and a <strong>source Observable</strong> that emits an integer every 300 millisecond. Then we <strong>subscribe</strong> the <strong>Subject</strong> to the <strong>Observable</strong>. After that, we <strong>subscribe</strong> an <strong>Observer</strong> to the <strong>Subject</strong> itself. The Subject now behaves as an Observable.</p>
<p>Next we make the Subject <strong>emit values of its own</strong> (message1 and message2). In the final result, we get the Subject’s own messages and then the proxied values from the source Observable. The values from the Observable come later because they are <strong>asynchronous</strong>, whereas we made the Subject’s own values immediate. Notice that even if we tell the source Observable to take the first five values, the output shows only the first three. That’s because after one second we call <strong>onCompleted</strong> on the Subject. This <strong>finishes</strong> the <strong>notifications</strong> to all subscriptions and overrides the take operator in this case.</p>
<h3 id="AsyncSubject"><a href="#AsyncSubject" class="headerlink" title="AsyncSubject"></a>AsyncSubject</h3><p>AsyncSubject emits the <strong>last value</strong> of a sequence only if the sequence completes. This value is then <strong>cached forever</strong>, and any Observer that subscribes after the value has been emitted will receive it right away. AsyncSubject is convenient for asynchronous operations that <strong>return a single value</strong>, such as Ajax requests.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> delayedRange = Rx.Observable.range(<span class="number">0</span>, <span class="number">5</span>).delay(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">var</span> subject = <span class="keyword">new</span> Rx.AsyncSubject();</span><br><span class="line">delayedRange.subscribe(subject);</span><br><span class="line">subject.subscribe(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onNext</span>(<span class="params">item</span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'Value:'</span>, item); &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onError</span>(<span class="params">err</span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'Error:'</span>, err); &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onCompleted</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'Completed.'</span>); &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Value: 4 </span></span><br><span class="line"><span class="comment">// Completed.</span></span><br></pre></td></tr></table></figure>
<h3 id="BehaviorSubject"><a href="#BehaviorSubject" class="headerlink" title="BehaviorSubject"></a>BehaviorSubject</h3><p>会有一个 placehodler，<code>var subject = new Rx.BehaviorSubject(&#39;Waiting for content&#39;);</code>。</p>
<p>会等待 remote source 给出一个值，然后就用 remote source 代替。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">subject.subscribe(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.body.textContent = result.response || result;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.body.textContent = <span class="string">'There was an error retrieving content'</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">Rx.DOM.get(<span class="string">'/remote/content'</span>).subscribe(subject);</span><br></pre></td></tr></table></figure>
<p>类似于，就是，Subject，但是他 subscrib 的是一个值（或者自己 onNext 了一个值）。</p>
<h3 id="ReplaySubject"><a href="#ReplaySubject" class="headerlink" title="ReplaySubject"></a>ReplaySubject</h3><p>A ReplaySubject caches its values and re-emits them to any Observer that sub- scribes late to it. Unlike with AsyncSubject, the sequence doesn’t need to be completed for this to happen.</p>
<p>及时是后面才 subscribe，但是会回放 observables 上所有的值。</p>
<img src="/2016/03/14/Read-Reactive-Programming-with-RxJS/ReplaySubject.png" alt="ReplaySubject" title="ReplaySubject">
</div></article></div></section><footer><div class="paginator"><a href="/2016/03/14/Redux-RxJS/" class="prev">上一篇</a><a href="/2016/03/13/Gulp-API/" class="next">下一篇</a></div></footer><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>